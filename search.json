[{"path":"index.html","id":"bienvenue","chapter":"Bienvenue!","heading":"Bienvenue!","text":"Il s’agit du site en français de Geocomputation R, un livre sur l’analyse, la visualisation et la modélisation des données géographiques. Le site en anglais est ici.Note: La première édition été imprimée par CRC Press dans la collection R Series.\nIl est possible de l’acheter chez CRC Press, ou sur Amazon, la première version est aussi hebergée sur bookdown.org.Inspiré par le mouvement libriste et l’Open Source Software Geospatial (FOSS4G), le code et le texte qui sous-tendent ce livre sont ouverts, ce qui garantit que le contenu est reproductible, transparent et accessible.\nL’hébergement du code source sur GitHub permet à quiconque d’interagir avec le projet en ouvrant des questions ou en contribuant au nouveau contenu et à la correction des fautes de frappe pour le bénéfice de tous.\nLa version en ligne du livre est hébergée sur geocompr.github.io et mise à jour par GitHub Actions.\nL’état actuel de sa construction est le suivant :Cette version du livre en français été produite via l’action GitHub du 2022-03-03. Ce travail est sous licence : Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.","code":""},{"path":"index.html","id":"comment-contribuer","chapter":"Bienvenue!","heading":"Comment contribuer ?","text":"bookdown rend l’édition d’un livre aussi facile que l’édition d’un wiki, à condition d’avoir un compte GitHub (inscription sur github.com).\nUne fois connecté à GitHub, cliquez sur l’icône “Edit page” dans le panneau de droite du site Web du livre.\nVous accéderez ainsi à une version modifiable du fichier source R Markdown qui généré la page sur laquelle vous vous trouvez.Pour signaler un problème concernant le contenu du livre (par exemple, un code qui ne fonctionne pas) ou pour demander une fonctionnalité, consultez la [liste des issues] (https://github.com/Robinlovelace/geocompr/issues).Les mainteneurs et les contributeurs doivent suivre les règles de conduite de ce dépôt : CODE CONDUCT.","code":""},{"path":"index.html","id":"reproducibilité","chapter":"Bienvenue!","heading":"Reproducibilité","text":"Le moyen le plus rapide de reproduire le contenu du livre si vous êtes novice en matière de données géographiques avec R peut être via le navigateur web, grâce à Binder.\nEn cliquant sur le lien ci-dessous, vous ouvrirez une nouvelle fenêtre contenant RStudio Server dans votre navigateur Web, ce qui vous permettra d’ouvrir les fichiers du chapitre et d’exécuter des morceaux de code pour vérifier que le code est reproductible.Si vous voyez quelque chose comme l’image ci-dessous, félicitations, cela fonctionné et vous pouvez commencer à explorer la géocomputation avec R dans un environnement cloud.(tout en étant conscient des consignes d’utilisation de mybinder.org):\nFIGURE 0.1: Capture d’écran du code reproductible contenu dans Geocomputation avec R s’exécutant dans RStudio Server sur un navigateur servi par Binder.\nPour reproduire le code du livre sur votre propre ordinateur, vous avez besoin d’une version récente de R et des paquets à jour.\nIls peuvent être installés en utilisant le paquet remotes.Après avoir installé les dépendances du livre, vous pouvez reconstruire le livre à des fins de test et d’enseignement.\nPour ce faire, vous devez télécharger et déziper ou cloner le code source du libre.\nAprès avoir ouvert le projet geocompr.Rproj dans RStudio (ou ouvert le dossier dans un autre IDE tel que VS Code), vous devriez être en mesure de reproduire le contenu avec la commande suivante :La page GitHub contient plus de détail pour reproduire ce livre.","code":"\ninstall.packages(\"remotes\")\nremotes::install_github(\"geocompr/geocompkg\")\nbookdown::serve_book(\".\")"},{"path":"index.html","id":"soutenir-le-projet","chapter":"Bienvenue!","heading":"Soutenir le projet","text":"Si vous trouvez ce livre utile (sa traduction ou sa version originale), vous pouvez le soutenir :En en parlant à d’autres personnesEn communiquant sur le livre dans les réseaux sociaux, par exemple, via #geocompr hashtag sur Twitter (cf. notre Guestbook sur geocompr.github.io) ou en référençant les cours mobilisant le livreLe citant ou le metre en lien‘Starring’ le dépôt GitHub geocomprEcrivant un recension, sur Amazon ou GoodreadsPosant des questions ou faire des suggestions de contenus sur GitHub ou Twitter.Achetant une copiePlus de détails sur le github.com/Robinlovelace/geocompr.L’icône du globe utilisé en couverture de ce livre été créé par Jean-Marc Viglino et est sous licence CC-4.0 International.","code":""},{"path":"foreword-1st-edition.html","id":"foreword-1st-edition","chapter":"Foreword (1st Edition)","heading":"Foreword (1st Edition)","text":"‘spatial’ R always broad, seeking provide integrate tools geography, geoinformatics, geocomputation spatial statistics anyone interested joining : joining asking interesting questions, contributing fruitful research questions, writing improving code.\n, ‘spatial’ R always included open source code, open data reproducibility.‘spatial’ R also sought open interaction many branches applied spatial data analysis, also implement new advances data representation methods analysis expose cross-disciplinary scrutiny.\nbook demonstrates, often alternative workflows similar data similar results, may learn comparisons others create understand workflows.\nincludes learning similar communities around Open Source GIS complementary languages Python, Java .R’s wide range spatial capabilities never evolved without people willing share creating adapting.\nmight include teaching materials, software, research practices (reproducible research, open data), combinations .\nR users also benefitted greatly ‘upstream’ open source geo libraries GDAL, GEOS PROJ.book clear example , curious willing join , can find things need match aptitudes.\nadvances data representation workflow alternatives, ever increasing numbers new users often without applied quantitative command-line exposure, book kind really needed.\nDespite effort involved, authors supported pressing forward publication., fresh book ready go; authors tried many tutorials workshops, readers instructors able benefit knowing contents continue tried people like .\nEngage authors wider R-spatial community, see value choice building workflows important, enjoy applying learn things care .Roger BivandBergen, September 2018","code":""},{"path":"preface.html","id":"preface","chapter":"Preface","heading":"Preface","text":"","code":""},{"path":"preface.html","id":"who-this-book-is-for","chapter":"Preface","heading":"Who this book is for","text":"book people want analyze, visualize model geographic data open source software.\nbased R, statistical programming language powerful data processing, visualization geospatial capabilities.\nbook covers wide range topics interest wide range people many different backgrounds, especially:People learned spatial analysis skills using desktop Geographic Information System (GIS), QGIS, ArcGIS, GRASS SAGA, want access powerful (geo)statistical visualization programming language benefits command-line approach (Sherman 2008):\n\nadvent ‘modern’ GIS software, people want point click way life. ’s good, tremendous amount flexibility power waiting command line.\nPeople learned spatial analysis skills using desktop Geographic Information System (GIS), QGIS, ArcGIS, GRASS SAGA, want access powerful (geo)statistical visualization programming language benefits command-line approach (Sherman 2008):advent ‘modern’ GIS software, people want point click way life. ’s good, tremendous amount flexibility power waiting command line.Graduate students researchers fields specializing geographic data including Geography, Remote Sensing, Planning, GIS Geographic Data ScienceGraduate students researchers fields specializing geographic data including Geography, Remote Sensing, Planning, GIS Geographic Data ScienceAcademics post-graduate students working geographic data — fields Geology, Regional Science, Biology Ecology, Agricultural Sciences, Archaeology, Epidemiology, Transport Modeling, broadly defined Data Science — require power flexibility R researchAcademics post-graduate students working geographic data — fields Geology, Regional Science, Biology Ecology, Agricultural Sciences, Archaeology, Epidemiology, Transport Modeling, broadly defined Data Science — require power flexibility R researchApplied researchers analysts public, private third-sector organizations need reproducibility, speed flexibility command-line language R applications dealing spatial data diverse Urban Transport Planning, Logistics, Geo-marketing (store location analysis) Emergency PlanningApplied researchers analysts public, private third-sector organizations need reproducibility, speed flexibility command-line language R applications dealing spatial data diverse Urban Transport Planning, Logistics, Geo-marketing (store location analysis) Emergency PlanningThe book designed intermediate--advanced R users interested geocomputation R beginners prior experience geographic data.\nnew R geographic data, discouraged: provide links materials describe nature spatial data beginner’s perspective Chapter 2 links provided .","code":""},{"path":"preface.html","id":"how-to-read-this-book","chapter":"Preface","heading":"How to read this book","text":"book divided three parts:Part : Foundations, aimed getting --speed geographic data R.Part II: Extensions, covers advanced techniques.Part III: Applications, real-world problems.chapters get progressively harder recommend reading book order.\nmajor barrier geographical analysis R steep learning curve.\nchapters Part aim address providing reproducible code simple datasets ease process getting started.important aspect book teaching/learning perspective exercises end chapter.\nCompleting develop skills equip confidence needed tackle range geospatial problems.\nSolutions exercises, number extended examples, provided book’s supporting website, geocompr.github.io.Impatient readers welcome dive straight practical examples, starting Chapter 2.\nHowever, recommend reading wider context Geocomputation R Chapter 1 first.\nnew R, also recommend learning language attempting run code chunks provided chapter (unless ’re reading book understanding concepts).\nFortunately R beginners R supportive community developed wealth resources can help.\nparticularly recommend three tutorials: R Data Science (Grolemund Wickham 2016) Efficient R Programming (Gillespie Lovelace 2016), especially Chapter 2 (installing setting-R/RStudio) Chapter 10 (learning learn), introduction R (R Core Team, Smith, Team 2021).","code":""},{"path":"preface.html","id":"why-r","chapter":"Preface","heading":"Why R?","text":"Although R steep learning curve, command-line approach advocated book can quickly pay .\n’ll learn subsequent chapters, R effective tool tackling wide range geographic data challenges.\nexpect , practice, R become program choice geospatial toolbox many applications.\nTyping executing commands command-line , many cases, faster pointing--clicking around graphical user interface (GUI) desktop GIS.\napplications Spatial Statistics modeling R may realistic way get work done.outlined Section 1.2, many reasons using R geocomputation:\nR well-suited interactive use required many geographic data analysis workflows compared languages.\nR excels rapidly growing fields Data Science (includes data carpentry, statistical learning techniques data visualization) Big Data (via efficient interfaces databases distributed computing systems).\nFurthermore R enables reproducible workflow: sharing scripts underlying analysis allow others build-work.\nensure reproducibility book made source code available github.com/Robinlovelace/geocompr.\nfind script files code/ folder generate figures:\ncode generating figure provided main text book, name script file generated provided caption (see example caption Figure ??).languages Python, Java C++ can used geocomputation excellent resources learning geocomputation without R, discussed Section 1.3.\nNone provide unique combination package ecosystem, statistical capabilities, visualization options, powerful IDEs offered R community.\nFurthermore, teaching use one language (R) depth, book equip concepts confidence needed geocomputation languages.","code":""},{"path":"preface.html","id":"real-world-impact","chapter":"Preface","heading":"Real-world impact","text":"Geocomputation R equip knowledge skills tackle wide range issues, including scientific, societal environmental implications, manifested geographic data.\ndescribed Section 1.1, geocomputation using computers process geographic data:\nalso real-world impact.\ninterested wider context motivations behind book, read ; covered Chapter 1..","code":""},{"path":"preface.html","id":"acknowledgements","chapter":"Preface","heading":"Acknowledgements","text":"","code":""},{"path":"intro.html","id":"intro","chapter":"1 Introduction","heading":"1 Introduction","text":"book using power computers things geographic data.\nteaches range spatial skills, including: reading, writing manipulating geographic data; making static interactive maps; applying geocomputation solve real-world problems; modeling geographic phenomena.\ndemonstrating various geographic operations can linked, reproducible ‘code chunks’ intersperse prose, book also teaches transparent thus scientific workflow.\nLearning use wealth geospatial tools available R command line can exciting, creating new ones can truly liberating.\nUsing command-line driven approach taught throughout, programming techniques covered Chapter ??, can help remove constraints creativity imposed software.\nreading book completing exercises, therefore feel empowered strong understanding possibilities opened R’s impressive geographic capabilities, new skills solve real-world problems geographic data, ability communicate work maps reproducible code.last decades free open source software geospatial (FOSS4G) progressed astonishing rate.\nThanks organizations OSGeo, geographic data analysis longer preserve expensive hardware software: anyone can now download run high-performance spatial libraries.\nOpen source Geographic Information Systems (GIS), QGIS, made geographic analysis accessible worldwide.\nGIS programs tend emphasize graphical user interfaces (GUIs), unintended consequence discouraging reproducibility (although many can used command line ’ll see Chapter ??).\nR, contrast, emphasizes command line interface (CLI).\nsimplistic comparison different approaches illustrated Table 1.1.TABLE 1.1: Differences emphasis software packages (Graphical User Interface (GUI) Geographic Information Systems (GIS) R).book motivated importance reproducibility scientific research (see note ).\naims make reproducible geographic data analysis workflows accessible, demonstrate power open geospatial software available command-line.\n“Interfaces software part R” (Eddelbuettel Balamuta 2018).\nmeans addition outstanding ‘house’ capabilities, R allows access many spatial software libraries, explained Section 1.2 demonstrated Chapter ??.\ngoing details software, however, worth taking step back thinking mean geocomputation.Reproducibility major advantage command-line interfaces, mean practice?\ndefine follows: “process results can generated others using publicly accessible code.”","code":""},{"path":"intro.html","id":"what-is-geocomputation","chapter":"1 Introduction","heading":"1.1 What is geocomputation?","text":"Geocomputation young term, dating back first conference subject 1996.1\ndistinguished geocomputation (time) commonly used term ‘quantitative geography’, early advocates proposed, emphasis “creative experimental” applications (Longley et al. 1998) development new tools methods (Openshaw Abrahart 2000):\n“GeoComputation using various different types geodata developing relevant geo-tools within overall context ‘scientific’ approach.”\nbook aims go beyond teaching methods code; end able use geocomputational skills, “practical work beneficial useful” (Openshaw Abrahart 2000).approach differs early adopters Stan Openshaw, however, emphasis reproducibility collaboration.\nturn 21st Century, unrealistic expect readers able reproduce code examples, due barriers preventing access necessary hardware, software data.\nFast-forward two decades things progressed rapidly.\nAnyone access laptop ~4GB RAM can realistically expect able install run software geocomputation publicly accessible datasets, widely available ever (see Chapter ??).2\nUnlike early works field, work presented book reproducible using code example data supplied alongside book, R packages spData, installation covered Chapter 2.Geocomputation closely related terms including: Geographic Information Science (GIScience); Geomatics; Geoinformatics; Spatial Information Science; Geoinformation Engineering (Longley 2015); Geographic Data Science (GDS).\nterm shares emphasis ‘scientific’ (implying reproducible falsifiable) approach influenced GIS, although origins main fields application differ.\nGDS, example, emphasizes ‘data science’ skills large datasets, Geoinformatics tends focus data structures.\noverlaps terms larger differences use geocomputation rough synonym encapsulating :\nseek use geographic data applied scientific work.\nUnlike early users term, however, seek imply cohesive academic field called ‘Geocomputation’ (‘GeoComputation’ Stan Openshaw called ).\nInstead, define term follows: working geographic data computational way, focusing code, reproducibility modularity.Geocomputation recent term influenced old ideas.\ncan seen part Geography, 2000+ year history (Talbert 2014);\nextension Geographic Information Systems (GIS) (Neteler Mitasova 2008), emerged 1960s (Coppock Rhind 1991).Geography played important role explaining influencing humanity’s relationship natural world long invention computer, however.\nAlexander von Humboldt’s travels South America early 1800s illustrates role:\nresulting observations lay foundations traditions physical plant geography, also paved way towards policies protect natural world (Wulf 2015).\nbook aims contribute ‘Geographic Tradition’ (Livingstone 1992) harnessing power modern computers open source software.book’s links older disciplines reflected suggested titles book: Geography R R GIS.\nadvantages.\nformer conveys message comprises much just spatial data:\nnon-spatial attribute data inevitably interwoven geometry data, Geography something map.\nlatter communicates book using R GIS, perform spatial operations geographic data (Bivand, Pebesma, Gómez-Rubio 2013).\nHowever, term GIS conveys connotations (see Table 1.1) simply fail communicate one R’s greatest strengths:\nconsole-based ability seamlessly switch geographic non-geographic data processing, modeling visualization tasks.\ncontrast, term geocomputation implies reproducible creative programming.\ncourse, (geocomputational) algorithms powerful tools can become highly complex.\nHowever, algorithms composed smaller parts.\nteaching foundations underlying structure, aim empower create innovative solutions geographic data problems.","code":""},{"path":"intro.html","id":"why-use-r-for-geocomputation","chapter":"1 Introduction","heading":"1.2 Why use R for geocomputation?","text":"Early geographers used variety tools including barometers, compasses sextants advance knowledge world (Wulf 2015).\ninvention marine chronometer 1761 became possible calculate longitude sea, enabling ships take direct routes.Nowadays lack geographic data hard imagine.\nEvery smartphone global positioning (GPS) receiver multitude sensors devices ranging satellites semi-autonomous vehicles citizen scientists incessantly measure every part world.\nrate data produced overwhelming.\nautonomous vehicle, example, can generate 100 GB data per day (Economist 2016).\nRemote sensing data satellites become large analyze corresponding data single computer, leading initiatives OpenEO.‘geodata revolution’ drives demand high performance computer hardware efficient, scalable software handle extract signal noise, understand perhaps change world.\nSpatial databases enable storage generation manageable subsets vast geographic data stores, making interfaces gaining knowledge vital tools future.\nR one tool, advanced analysis, modeling visualization capabilities.\ncontext focus book language (see Wickham 2019).\nInstead use R ‘tool trade’ understanding world, similar Humboldt’s use tools gain deep understanding nature complexity interconnections (see Wulf 2015).\nAlthough programming can seem like reductionist activity, aim teach geocomputation R fun, understanding world.R multi-platform, open source language environment statistical computing graphics (r-project.org/).\nwide range packages, R also supports advanced geospatial statistics, modeling visualization.\n\nNew integrated development environments (IDEs) RStudio made R user-friendly many, easing map making panel dedicated interactive visualization.core, R object-oriented, functional programming language (Wickham 2019), specifically designed interactive interface software (Chambers 2016).\nlatter also includes many ‘bridges’ treasure trove GIS software, ‘geolibraries’ functions (see Chapter ??).\nthus ideal quickly creating ‘geo-tools’, without needing master lower level languages (compared R) C, FORTRAN Java (see Section 1.3).\n\ncan feel like breaking free metaphorical ‘glass ceiling’ imposed GUI-based proprietary geographic information systems (see Table 1.1 definition GUI).\nFurthermore, R facilitates access languages:\npackages Rcpp reticulate enable access C++ Python code, example.\nmeans R can used ‘bridge’ wide range geospatial programs (see Section 1.3).Another example showing R’s flexibility evolving geographic capabilities interactive map making.\n’ll see Chapter ??, statement R “limited interactive [plotting] facilities” (Bivand, Pebesma, Gómez-Rubio 2013) longer true.\ndemonstrated following code chunk, creates Figure 1.1 (functions generate plot covered Section ??).\nFIGURE 1.1: blue markers indicate authors . basemap tiled image Earth night provided NASA. Interact online version geocompr.robinlovelace.net, example zooming clicking popups.\ndifficult produce Figure 1.1 using R years ago, let alone interactive map.\nillustrates R’s flexibility , thanks developments knitr leaflet, can used interface software, theme recur throughout book.\nuse R code, therefore, enables teaching geocomputation reference reproducible examples representing real world phenomena, rather just abstract concepts.","code":"\nlibrary(leaflet)\npopup = c(\"Robin\", \"Jakub\", \"Jannes\")\nleaflet() %>%\n  addProviderTiles(\"NASAGIBS.ViirsEarthAtNight2012\") %>%\n  addMarkers(lng = c(-3, 23, 11),\n             lat = c(52, 53, 49), \n             popup = popup)"},{"path":"intro.html","id":"software-for-geocomputation","chapter":"1 Introduction","heading":"1.3 Software for geocomputation","text":"R powerful language geocomputation many options geographic data analysis providing thousands geographic functions.\nAwareness languages geocomputation help decide different tool may appropriate specific task, place R wider geospatial ecosystem.\nsection briefly introduces languages C++, Java Python geocomputation, preparation Chapter ??.important feature R (Python) interpreted language.\nadvantageous enables interactive programming Read–Eval–Print Loop (REPL):\ncode entered console immediately executed result printed, rather waiting intermediate stage compilation.\nhand, compiled languages C++ Java tend run faster (compiled).C++ provides basis many GIS packages QGIS, GRASS SAGA sensible starting point.\nWell-written C++ fast, making good choice performance-critical applications processing large geographic datasets, harder learn Python R.\nC++ become accessible Rcpp package, provides good ‘way ’ C programming R users.\nProficiency low-level languages opens possibility creating new, high-performance ‘geoalgorithms’ better understanding GIS software works (see Chapter ??).Java another important versatile language geocomputation.\nGIS packages gvSig, OpenJump uDig written Java.\nmany GIS libraries written Java, including GeoTools JTS, Java Topology Suite (GEOS C++ port JTS).\nFurthermore, many map server applications use Java including Geoserver/Geonode, deegree 52°North WPS.Java’s object-oriented syntax similar C++.\nmajor advantage Java platform-independent (unusual compiled language) highly scalable, making suitable language IDEs RStudio, book written.\nJava fewer tools statistical modeling visualization Python R, although can used data science (Brzustowicz 2017).Python important language geocomputation especially many Desktop GIS GRASS, SAGA QGIS provide Python API (see Chapter ??).\nLike R, popular tool data science.\nlanguages object-oriented, many areas overlap, leading initiatives reticulate package facilitates access Python R Ursa Labs initiative support portable libraries benefit entire open source data science ecosystem.practice R Python strengths extent use less important domain application communication results.\nLearning either provide head-start learning .\nHowever, major advantages R Python geocomputation.\nincludes much better support geographic data models vector raster language (see Chapter 2) corresponding visualization possibilities (see Chapters 2 ??).\nEqually important, R unparalleled support statistics, including spatial statistics, hundreds packages (unmatched Python) supporting thousands statistical methods.major advantage Python general-purpose programming language.\nused many domains, including desktop software, computer games, websites data science.\nPython often shared language different (geocomputation) communities can seen ‘glue’ holds many GIS programs together.\nMany geoalgorithms, including QGIS ArcMap, can accessed Python command line, making well-suited starter language command-line GIS.3For spatial statistics predictive modeling, however, R second--none.\nmean must choose either R Python: Python supports common statistical techniques (though R tends support new developments spatial statistics earlier) many concepts learned Python can applied R world.\n\n\nLike R, Python also supports geographic data analysis manipulation packages osgeo, Shapely, NumPy PyGeoProcessing (Garrard 2016).","code":""},{"path":"intro.html","id":"r-ecosystem","chapter":"1 Introduction","heading":"1.4 R’s spatial ecosystem","text":"many ways handle geographic data R, dozens packages area.4\nbook endeavor teach state---art field whilst ensuring methods future-proof.\nLike many areas software development, R’s spatial ecosystem rapidly evolving (Figure 1.2).\nR open source, developments can easily build previous work, ‘standing shoulders giants’, Isaac Newton put 1675.\napproach advantageous encourages collaboration avoids ‘reinventing wheel’.\npackage sf (covered Chapter 2), example, builds predecessor sp.surge development time (interest) ‘R-spatial’ followed award grant R Consortium development support Simple Features, open-source standard model store access vector geometries.\nresulted sf package (covered Section ??).\nMultiple places reflect immense interest sf.\nespecially true R-sig-Geo Archives, long-standing open access email list containing much R-spatial wisdom accumulated years.\nFIGURE 1.2: Downloads selected R packages working geographic data. y-axis shows average number downloads per day, within 91-day rolling window.\nnoteworthy shifts wider R community, exemplified data processing package dplyr (released 2014) influenced shifts R’s spatial ecosystem.\nAlongside packages shared style emphasis ‘tidy data’ (including, e.g., ggplot2), dplyr placed tidyverse ‘metapackage’ late 2016.\n\n\ntidyverse approach, focus long-form data fast intuitively named functions, become immensely popular.\nled demand ‘tidy geographic data’ partly met sf.\nobvious feature tidyverse tendency packages work harmony.\n\n\nequivalent geoverse, attempts harmonization packages hosted r-spatial organization growing number packages use sf (Table 1.2).TABLE 1.2: top 5 downloaded packages depend sf, terms average number downloads per day previous month. 2021-11-19 289 packages import sf.Parallel group developments relates rspatial set packages.5\nmain member terra package spatial raster handling (see Section ??).","code":""},{"path":"intro.html","id":"the-history-of-r-spatial","chapter":"1 Introduction","heading":"1.5 The history of R-spatial","text":"many benefits using recent spatial packages sf, also important aware history R’s spatial capabilities: many functions, use-cases teaching material contained older packages.\ncan still useful today, provided know look.\n\nR’s spatial capabilities originated early spatial packages S language (Bivand Gebhardt 2000).\n\n1990s saw development numerous S scripts handful packages spatial statistics.\nR packages arose 2000 R packages various spatial methods “point pattern analysis, geostatistics, exploratory spatial data analysis spatial econometrics”, according article presented GeoComputation 2000 (Bivand Neteler 2000).\n, notably spatial, sgeostat splancs still available CRAN (B. S. Rowlingson Diggle 1993; B. Rowlingson Diggle 2017; Venables Ripley 2002; Majure Gebhardt 2016).subsequent article R News (predecessor R Journal) contained overview spatial statistical software R time, much based previous code written S/S-PLUS (Ripley 2001).\noverview described packages spatial smoothing interpolation, including akima geoR (Akima Gebhardt 2016; Jr Diggle 2016), point pattern analysis, including splancs (B. Rowlingson Diggle 2017) spatstat (Baddeley, Rubak, Turner 2015).following R News issue (Volume 1/3) put spatial packages spotlight , detailed introduction splancs commentary future prospects regarding spatial statistics (Bivand 2001).\nAdditionally, issue introduced two packages testing spatial autocorrelation eventually became part spdep (Bivand 2017).\nNotably, commentary mentions need standardization spatial interfaces, efficient mechanisms exchanging data GIS, handling spatial metadata coordinate reference systems (CRS).maptools (written Nicholas Lewin-Koh; Bivand Lewin-Koh (2017)) another important package time.\nInitially maptools just contained wrapper around shapelib permitted reading ESRI Shapefiles geometry nested lists.\ncorresponding nowadays obsolete S3 class called “Map” stored list alongside attribute data frame.\nwork “Map” class representation nevertheless important since directly fed sp prior publication CRAN.2003 Roger Bivand published extended review spatial packages.\nproposed class system support “data objects offered GDAL”, including ‘fundamental’ point, line, polygon, raster types.\nFurthermore, suggested interfaces external libraries form basis modular R packages (Bivand 2003).\nlarge extent ideas realized packages rgdal sp.\nprovided foundation spatial data analysis R, described Applied Spatial Data Analysis R (ASDAR) (Bivand, Pebesma, Gómez-Rubio 2013), first published 2008.\nTen years later, R’s spatial capabilities evolved substantially still build ideas set-Bivand (2003):\ninterfaces GDAL PROJ, example, still power R’s high-performance geographic data /O CRS transformation capabilities (see Chapters ?? ??, respectively).rgdal, released 2003, provided GDAL bindings R greatly enhanced ability import data previously unavailable geographic data formats.\ninitial release supported raster drivers subsequent enhancements provided support coordinate reference systems (via PROJ library), reprojections import vector file formats (see Chapter ?? file formats).\nMany additional capabilities developed Barry Rowlingson released rgdal codebase 2006 (see B. Rowlingson et al. 2003 R-help email list context).sp, released 2005, overcame R’s inability distinguish spatial non-spatial objects (Pebesma Bivand 2005).\nsp grew workshop Vienna 2003 hosted sourceforge migrating R-Forge.\nPrior 2005, geographic coordinates generally treated like number.\nsp changed classes generic methods supporting points, lines, polygons grids, attribute data.sp stores information bounding box, coordinate reference system attributes slots Spatial objects using S4 class system,\nenabling data operations work geographic data (see Section ??).\n, sp provides generic methods summary() plot() geographic data.\nfollowing decade, sp classes rapidly became popular geographic data R number packages depended increased around 20 2008 100 2013 (Bivand, Pebesma, Gómez-Rubio 2013).\n2018 almost 500 packages rely sp, making important part R ecosystem.\nProminent R packages using sp include: gstat, spatial spatio-temporal geostatistics; geosphere, spherical trigonometry; adehabitat used analysis habitat selection animals (Pebesma Graeler 2018; Calenge 2006; Hijmans 2016).rgdal sp solved many spatial issues, R still lacked ability geometric operations (see Chapter ??).\nColin Rundel addressed issue developing rgeos, R interface open-source geometry library (GEOS) Google Summer Code project 2010 (Bivand Rundel 2018).\nrgeos enabled GEOS manipulate sp objects, functions gIntersection().Another limitation sp — restricted support raster data — overcome raster, first released 2010 (Hijmans 2017).\nclass system functions support range raster operations outlined Section ??.\nkey feature raster ability work datasets large fit RAM (R’s interface PostGIS supports -disk operations vector geographic data).\nraster also supports map algebra (see Section ??).parallel developments class systems methods came support R interface dedicated GIS software.\nGRASS (Bivand 2000) follow-packages spgrass6 rgrass7 (GRASS GIS 6 7, respectively) prominent examples direction (Bivand 2016a, 2016b).\nexamples bridges R GIS include RSAGA (Brenning, Bangs, Becker 2018, first published 2008), RPyGeo (Brenning 2012, first published 2008), RQGIS (Muenchow, Schratz, Brenning 2017, first published 2016), rqgisprocess (see Chapter ??).\n\nVisualization focus initially, bulk R-spatial development focused analysis geographic operations.\nsp provided methods map making using base lattice plotting system demand growing advanced map making capabilities.\nRgoogleMaps first released 2009, allowed overlay R spatial data top ‘basemap’ tiles online services Google Maps OpenStreetMap (Loecher Ropkins 2015).\n\nfollowed ggmap package added similar ‘basemap’ tiles capabilities ggplot2 (Kahle Wickham 2013).\nThough ggmap facilitated map-making ggplot2, utility limited need fortify spatial objects, means converting long data frames.\nworks well points computationally inefficient lines polygons, since coordinate (vertex) converted row, leading huge data frames represent complex geometries.\nAlthough geographic visualization tended focus vector data, raster visualization supported raster received boost release rasterVis, described book subject spatial temporal data visualization (Lamigueiro 2018).\n2018 map making R hot topic dedicated packages tmap, leaflet mapview supporting class system provided sf, focus next chapter (see Chapter ?? visualization).Since 2018, movement modernizing basic R packages related handling spatial data continued.\n\nterra – successor raster package aimed better performance straightforward user interface firstly released (see Chapter ??) 2020 (Hijmans 2021).\nmid-2021, significant change made sf package incorporating spherical geometry calculations.\nSince change, default, many spatial operations data geographic CRSs apply C++ s2geometry library’s spherical geometry algorithms, types operations data projected CRSs still using GEOS.\n\n\nNew ideas spatial data representations also developed period.\n\n\nincludes stars package, closely connected sf, handling raster vector data cubes (Pebesma 2021) lidR processing airborne LiDAR (Light Detection Ranging) point clouds (Roussel et al. 2020).modernization several reasons, including emergence new technologies standard, impacts spatial software development outside R environment (Bivand 2021).\nimportant external factor affecting spatial software, including R spatial packages, major updates, including many breaking changes PROJ library begun 2018.\nimportantly, changes forced replacement proj4string WKT representation storage coordinate reference systems coordinates operations (learn Section 2.4 Chapter ??).\nSince 2018, progress spatial visualization tools R related factors.\nFirstly, new types spatial plots developed, including rayshader package offering combination raytracing multiple hill-shading methods produce 2D 3D data visualizations (Morgan-Wall 2021).\n\nSecondly, ggplot2 gained new spatial capabilities, mostly thanks ggspatial package adds spatial visualization elements, including scale bars north arrows (Dunnington 2021) gganimate enables smooth customizable spatial animations (Pedersen Robinson 2020).\nThirdly, performance visualizing large spatial dataset improved.\nespecially relates automatic plotting downscaled rasters tmap possibility using high-performance interactive rendering platforms mapview package, \"leafgl\" \"mapdeck\".\nLastly, existing mapping tools rewritten minimize dependencies, improve user interface, allow easier creation extensions.\nincludes mapsf package (successor cartography) (Giraud 2021) version 4 tmap package, internal code revised.late 2021, planned retirement rgdal, rgeos maptools end 2023 announced R-sig-Geo mailing list Roger Bivand.\nlarge impact existing workflows applying packages, also influence packages depend rgdal, rgeos maptools.\nTherefore, Bivand’s suggestion plan transition modern tools, including sf terra, explained book’s next chapters.","code":""},{"path":"intro.html","id":"exercises","chapter":"1 Introduction","heading":"1.6 Exercises","text":"E1. Think terms ‘GIS’, ‘GDS’ ‘geocomputation’ described . () best describes work like using geo* methods software ?E2. Provide three reasons using scriptable language R geocomputation instead using graphical user interface (GUI) based GIS QGIS.E3. Think real world problem like solve geographic data help people living local area sketch map geographic processes involved.E4. Consider datasets needed represent problem computationally sketch workflow processing , resulting outputs help inform decision making related problem thought previous exercise. Use pen paper digital sketching tool Excalidraw.","code":""},{"path":"spatial-class.html","id":"spatial-class","chapter":"2 La donnée géographique dans R","heading":"2 La donnée géographique dans R","text":"","code":""},{"path":"spatial-class.html","id":"prérequis","chapter":"2 La donnée géographique dans R","heading":"Prérequis","text":"C’est le premier chapitre pratique du livre. Il faut donc installer certains logiciels et les avoir un peu pratiqué.\nNous supposons que vous avez installé une version à jour de R et que vous êtes à l’aise avec les logiciels dotés d’une interface de ligne de commande, comme l’environnement de développement intégré (IDE) RStudio.\nSi vous débutez avec R, nous vous recommandons de lire le chapitre 2 du livre en ligne Efficient R Programming de Gillespie Lovelace (2016) et d’apprendre les bases du langage en vous référant à des ressources telles que Grolemund Wickham (2016).\nOrganisez votre travail (par exemple, avec des projets RStudio) et donnez aux scripts des noms judicieux tels que 02-chapter.R pour documenter le code que vous écrivez au fur et à mesure de votre apprentissage.\nLes paquets utilisés dans ce chapitre peuvent être installés à l’aide des commandes suivantes :6Tous les paquets nécessaires pour reproduire le contenu du livre peuvent être installés via la commande suivante : remotes::install_github(\"geocompr/geocompkg\").\nLes paquets nécessaires peuvent être “chargés” (techniquement, ils sont attachés) avec la fonction library() :Conformemant à la section ??, la sortie de library(sf) mentionne les versions des bibliothèques géographiques clés, comme GEOS, utilisées par ce paquet.Les autres paquets installés contiennent des données qui seront utilisées dans le livre:","code":"\ninstall.packages(\"sf\")\ninstall.packages(\"terra\")\ninstall.packages(\"spData\")\ninstall.packages(\"spDataLarge\", repos = \"https://nowosad.r-universe.dev\")\nlibrary(sf)          # classes et fonctions pour les données vectorielles\n#> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() is TRUE\nlibrary(terra)      # classes et fonctions pour les données rasters\nlibrary(spData)        # chargement de données geographiques\nlibrary(spDataLarge)   # chargement de données geographiques plus volumineuses"},{"path":"spatial-class.html","id":"intro-spatial-class","chapter":"2 La donnée géographique dans R","heading":"2.1 Introduction","text":"Ce chapitre fournit de brèves explications sur les modèles fondamentaux des données géographiques : vecteur et raster.\nNous présenterons la théorie qui sous-tend chaque modèle de données et les disciplines dans lesquelles ils prédominent, avant de démontrer leur mise en œuvre dans R.Le modèle de données vectoriel représente le monde à l’aide de points, de lignes et de polygones.\nCeux-ci ont des frontières discrètes et bien définies, ce qui signifie que les ensembles de données vectorielles ont généralement un haut niveau de précision (mais pas nécessairement d’exactitude, comme nous le verrons dans la section @ref(unités)).\nLe modèle de données raster divise la surface en pixel de taille constante.\nLes données rasters sont la base des images d’arrière-plan utilisées dans les cartes Web et constituent une source essentielle de données géographiques depuis les débuts de la photographie aérienne et des dispositifs de télédétection par satellite.\nLes rasters agrègent spatialement des informations à une résolution donnée. Ils maintiennent ainsi une consistance temporelle sur de grandes superficies (de nombreux jeux de données rasters sont disponibles à l’échelle planétaire).Que faut-il utiliser ?\nLa réponse dépend probablement de votre domaine d’application :Les données vectorielles ont tendance à dominer les sciences sociales parce que les constructions humaines ont tendance à avoir des frontières discrètes.Les données rasters dominent de nombreuses sciences de l’environnement en raison de la dépendance aux données de télédétection.Il y beaucoup de chevauchements dans certains domaines et les ensembles de données rasters et vectorielles peuvent être utilisés conjointement :\nles écologistes et les démographes, par exemple, utilisent couramment les deux.\nEn outre, il est possible de les convertir (voir la section ??).\nQue votre travail mobilise plus un type de jeux de données, vectorielles ou rasters, il reste utile de comprendre leurs modèles de données sous-jacents pour bien les utiliser, comme nous le verrons dans les chapitres suivants.\nCe livre utilise les paquets sf et terra pour travailler, respectivement, avec des données vectorielles et des jeux de données raster.","code":""},{"path":"spatial-class.html","id":"données-vectorielles","chapter":"2 La donnée géographique dans R","heading":"2.2 Données vectorielles","text":"Le modèle de données géographiques vectorielles est basé sur des points situés dans un système de coordonnées et de référence (SCR).\nLes points peuvent représenter des caractéristiques propres (par exemple, l’emplacement d’un arrêt de bus) ou être reliés entre eux pour former des géométries plus complexes telles que des lignes et des polygones.\nLa plupart des géométries construites avec des points ne sont qu’en deux dimensions (les CRS tridimensionnels contiennent une valeur supplémentaire \\(z\\), représentant généralement la hauteur au-dessus du niveau de la mer).Dans ce système, Londres, par exemple, peut être représentée par les coordonnées c(-0,1, 51,5).\nCela signifie que sa position est -0,1 degré est et 51,5 degrés nord par rapport au point d’origine.\nCe dernier se situe à 0 degré de longitude (le méridien d’origine) et à 0 degré de latitude (l’équateur) dans un SCR géographique (‘long/lat’) (Figure 2.1, panneau de gauche).\nCette même localisation pourrait également être approximée dans un SCR projeté avec des valeurs “Est/Nord” de c(530000, 180000) dans le [British National Grid] (https://en.wikipedia.org/wiki/Ordnance_Survey_National_Grid), ce qui signifie que Londres est située à 530 km Est et 180 km Nord de l’origine du SCR.\nCeci peut être vérifié visuellement : un peu plus de 5 “boîtes” — des zones carrées délimitées par les lignes de grille grises de 100 km de large — séparent le point représentant Londres de l’origine (Figure 2.1, panneau de droite).L’emplacement de l’origine de la grille nationale, dans la mer au-delà de la péninsule du sud-ouest de l’Angleterre, garantit que la plupart des lieux du Royaume-Uni auront des valeurs positives en abscisse et ordonnée.7\nLes SCR sont plus complexes, et seront abordées plus en détail dans les sections 2.4 et ??. Cependant pour les besoins de cette section, il suffit de savoir que les coordonnées consistent en deux nombres représentant la distance par rapport à un point d’origine, généralement dans les dimensions \\(x\\) puis \\(y\\).\nFIGURE 2.1: Représentation de données vectorielles (ponctuelles) dans laquelle l’emplacement de Londres (X rouge) est représenté par rapport à une origine (le cercle bleu). La carte de gauche représente un SCR géographique dont l’origine se situe à 0° de longitude et de latitude. Le graphique de droite représente un SCR projeté dont l’origine est située dans la mer à l’ouest de la péninsule du sud-ouest anglaise.\nsf fournit des classes informatiques pour les données géographiques vectorielles ainsi qu’une interface en ligne de commande pour des bibliothèques de géocomputation de bas niveau :GDAL, pour la lecture, l’écriture et la manipulation d’une large gamme de formats de données géographiques, couverte dans le chapitre ??PROJ, une puissante bibliothèque pour les transformations de systèmes de coordonnées, qui sous-tend le chapitre ??GEOS, un moteur de géométrie euclidienne pour les opérations telles que le calcul des tampons et des centroïdes sur les données avec un SCR projeté, couvert dans le chapitre ??S2, un moteur de géométrie sphérique écrit en C++ développé par Google, via le paquet s2, couvert dans la section 2.2.9 ci-dessous et dans le chapitre ??.\nLes informations concernant ces interfaces sont indiquées par sf lorsque que celui ci est chargé pour la première fois: via le message Linking GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() TRUE apparue en dessous de la commande library(sf) au tout début de ce chapitre. Ce message indique les versions des bibliothèques liées GEOS, GDAL et PROJ (chiffre pouvant varier au cours du temps et entre les ordinateurs) et si oui ou non l’interface avec S2 est activée.\nAujourd’hui, nous considérons que c’est un acquis, cependant, c’est grâce à l’intégration étroite entre les différentes bibliothèques géographiques qu’un travail de géocomputation reproductible est possible.Une fonctionnalité intéressante de sf est que vous pouvez changer le moteur de géométrie par défaut utilisé sur les données non projetées : “Désactiver” S2 peut être fait avec la commande sf::sf_use_s2(\"FALSE\"), ce qui signifie que le moteur de géométrie euclidienne GEOS sera utilisé par défaut pour toutes les opérations de géométrie, y compris celles sur les données non projetées.\nComme nous le verrons dans la Section 2.2.9, la géométrie euclidienne, ou plane, est basée sur un espace à 2 dimensions.\nLes moteurs de géométrie euclidienne tels que GEOS supposent des coordonnées “plates” (projetées), tandis que les moteurs de géométrie sphérique tels que S2 supposent des coordonnées non projetées (lon/lat).Cette section présente les classes sf en préparation des chapitres suivants (les chapitres ?? et ?? couvrent respectivement l’interface GEOS et GDAL)","code":""},{"path":"spatial-class.html","id":"une-introduction-aux-simple-features","chapter":"2 La donnée géographique dans R","heading":"2.2.1 Une introduction aux Simple Features","text":"Simple features est un Format ouvert développé et approuvé par l’Open Geospatial Consortium (OGC), une organisation à non lucratif dont nous reviendrons sur les activités dans un chapitre ultérieur (section ??).\n\nSimple Features est un modèle de données hiérarchique qui représente un large éventail de types géométriques.\nSur les 18 types géométriques pris en charge par la spécification, seuls 7 sont utilisés dans la grande majorité des recherches géographiques (voir Figure 2.2) ;\nces types géométriques de base sont entièrement pris en charge par le paquet R sf (Pebesma 2018).8\nFIGURE 2.2: Les types de Simple features pleinement disponibles dans sf.\nsf peut représenter tous les types de géométrie vectorielle courants (les classes de données raster ne sont pas prises en charge par sf) : points, lignes, polygones et leurs versions “multi” respectives (qui regroupent les caractéristiques du même type en une seule caractéristique).\n\n\nsf prend également en charge les collections de géométrie, qui peuvent contenir plusieurs types de géométrie dans un seul objet.\nsf fournit la même fonctionnalité (et plus) que celle fournie précédemment dans trois packages — sp pour les classes de données (Pebesma Bivand 2018), rgdal pour la lecture/écriture de données via une interface avec GDAL et PROJ (Bivand, Keitt, Rowlingson 2018) et rgeos pour les opérations spatiales via une interface avec GEOS (Bivand Rundel 2018).Comme expliqué au chapitre 1, les paquets géographiques de R ont une longue histoire d’interfaçage avec des bibliothèques de niveau inférieur, et sf poursuit cette tradition avec une interface unifiée vers les versions récentes de GEOS pour les opérations de géométrie, la bibliothèque GDAL pour la lecture et l’écriture de fichiers de données géographiques, et la bibliothèque PROJ pour la représentation et la transformation des systèmes de référence de coordonnées projetées.\nGrâce à s2,\n\n\n“une interface avec la bibliothèque de géométrie sphérique de Google [s2] (https://s2geometry.io/), sf également accès à des”mesures et opérations sur des géométries non planes” rapides et précises” (Bivand 2021).\nDepuis la version 1.0.0 de sf, lancée en juin 2021, la fonctionnalité s2 est maintenant utilisée par défaut sur les géométries avec des systèmes de coordonnées géographiques (longitude/latitude), une caractéristique unique de sf qui diffère des bibliothèques spatiales ne prenant en charge que GEOS pour les opérations de géométrie, comme le paquet Python GeoPandas.\nNous aborderons s2 dans les chapitres suivants.\n\nLa capacité de sf à intégrer plusieurs bibliothèques puissantes pour la géoinformatique dans un seul cadre est une réalisation remarquable qui réduit le “coût d’entrée” dans le monde de l’analyse reproductible des données géographiques avec des bibliothèques performantes.\nLa fonctionnalité de sf est bien documentée sur son site web à l’adresse [r-spatial.github.io/sf/] (https://r-spatial.github.io/sf/index.html) qui contient 7 vignettes.\nCelles-ci peuvent être visualisées hors ligne comme suit :Comme l’explique la première vignette, les objets de type simples features dans R sont stockés dans un tableau de données, les données géographiques occupant une colonne spéciale, généralement nommée “geom” ou “geometry”.\nNous allons utiliser le jeu de données world fourni par la bibliothèque spData, chargé au début de ce chapitre, pour montrer ce que sont les objets sf et comment ils fonctionnent.\nworld est un “tableau de données sf” contenant des colonnes spatiales et attributaires, dont les noms sont retournés par la fonction names() (la dernière colonne dans cet exemple contient les informations géographiques) :Le contenu de cette colonne geom donne aux objets sf leurs propriétés spatiales : world$geom est une ‘colonne de type liste’ qui contient toutes les coordonnées des polygones du pays.\n\nLes objets sf peuvent être tracés rapidement avec la fonction de base de R, plot() ;\nla commande suivante crée la figure 2.3.\nFIGURE 2.3: Cartes du monde utilisant le paquet sf, avec une dimension pour chaque attribut.\nNotez qu’au lieu de créer une seule carte par défaut pour les objets géographiques, comme le font la plupart des programmes SIG, la fonction plot() sur des objets sf retourne une carte pour chaque variable du jeux de données.\nCe comportement peut être utile pour explorer la distribution spatiale de différentes variables et est abordé plus en détail dans la section 2.2.3.Plus largement, traiter les objets géographiques comme des tableaux de données classiques avec des propriétés spatiales présente de nombreux avantages, surtout si vous avez déjà l’habitude de travailler avec des tableaux de données.\nPar exemple, la fonction très pratique summary(), fournit un aperçu utile des variables de l’objet world.Bien que nous n’ayons sélectionné qu’une seule variable pour la commande summary(), elle produit également un rapport sur la géométrie.\nCela démontre le comportement “permanent” des colonnes de type géométrie des objets sf, cela signifie que la géométrie est conservée à moins que l’utilisateur ne la supprime délibérément, comme nous le verrons dans la Section ??.\nLe résultat fournit un résumé rapide des données spatiales et non spatiales contenues dans world : l’espérance de vie moyenne est de 71 ans (allant de moins de 51 ans à plus de 83 ans avec une médiane de 73 ans) pour tous les pays.Il est important d’examiner de plus près le comportement de base et le contenu de cet objet simple feature, que l’peut utilement considérer comme un “spatial data frames”.Les objets sf sont faciles à extraire: le code ci-dessous extrait ses deux premières lignes et trois premières colonnes de world.\nLa sortie montre deux différences majeures par rapport à un data.frame standard : l’inclusion de données géographiques supplémentaires (geometry type, dimension, bbox et les informations SCR -epsg (SRID),proj4string) ainsi que la présence d'une colonnegeometry, ici nomméegeom` :Tout cela peut sembler assez complexe, surtout pour un système de classes qui est censé être simple.\nCependant, il y de bonnes raisons d’organiser les choses de cette façon et d’utiliser sf.Avant de décrire chaque type de géométrie géré par le paquet sf, il est utile de prendre un peu de recul pour comprendre les éléments constitutifs des objets de type sf.\nLa section 2.2.5 montre comment les objets simples features sont des tableau de données, avec des colonnes géométriques spéciales.\nCes colonnes spatiales sont souvent appelées geom ou geometry : ainsi world$geom fait référence à l’élément spatial de l’objet world décrit plus haut.\nCes colonnes géométriques sont des “colonnes de type liste” de la classe sfc (voir la section 2.2.7).\nPuis, à leur tour, les objets sfc sont composés d’un ou plusieurs objets de la classe sfg : des géométries simples features que nous décriverons dans la section 2.2.6.\n\nPour comprendre comment fonctionnent les composantes spatiales des simples features, il est essentiel de comprendre comment leurs géométries sont prises en comptes.\nC’est pourquoi nous couvrirons chacun des types de géométrie simples features actuellement pris en charge dans la section 2.2.4 puis nous continuerons en montrant comment ils peuvent être représentés dans R avec des objets sf, formés à la base d’objets sfg et sfc.","code":"\nvignette(package = \"sf\") # Qu'elles sont les vignettes disponibles\nvignette(\"sf1\")          # Une introduction à la bibliothèque \nclass(world)\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\nnames(world)\n#>  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n#>  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\nplot(world)\nsummary(world[\"lifeExp\"])\n#>     lifeExp                geom    \n#>  Min.   :50.6   MULTIPOLYGON :177  \n#>  1st Qu.:65.0   epsg:4326    :  0  \n#>  Median :72.9   +proj=long...:  0  \n#>  Mean   :70.9                      \n#>  3rd Qu.:76.8                      \n#>  Max.   :83.6                      \n#>  NA's   :10\nworld_mini = world[1:2, 1:3]\nworld_mini\n#> Simple feature collection with 2 features and 3 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -18.3 xmax: 180 ymax: -0.95\n#> Geodetic CRS:  WGS 84\n#> # A tibble: 2 × 4\n#>   iso_a2 name_long continent                                                geom\n#>   <chr>  <chr>     <chr>                                      <MULTIPOLYGON [°]>\n#> 1 FJ     Fiji      Oceania   (((-180 -16.6, -180 -16.5, -180 -16, -180 -16.1, -…\n#> 2 TZ     Tanzania  Africa    (((33.9 -0.95, 31.9 -1.03, 30.8 -1.01, 30.4 -1.13,…Le morceau de code précédent utilise `=` pour créer un nouvel objet appelé `world_mini` dans la commande `world_mini = world[1:2, 1:3]`.\nC´est ce qu´on appelle une affectation.\nUne commande équivalente pour obtenir le même résultat est `world_mini <- world[1:2, 1:3]`.\nBien que l´affectation par flèche soit plus couramment utilisée, nous utilisons l´affectation par égalité parce qu´elle est légèrement plus rapide à taper et plus facile à enseigner en raison de sa compatibilité avec les langages couramment utilisés tels que Python et JavaScript.\nL´utilisation de l´un ou l´autre est une question de préférence, tant que vous êtes cohérent (des paquets tels que **styler** peuvent être utilisés pour changer de style)."},{"path":"spatial-class.html","id":"pourquoi-simple-features","chapter":"2 La donnée géographique dans R","heading":"2.2.2 Pourquoi simple features?","text":"Les simple features sont un modèle de données largement utilisé qui sous-tend les structures de données de nombreuses applications SIG, notamment QGIS et PostGIS.\nL’un des principaux avantages de cette approche est que l’utilisation du modèle de données garantit que votre travail est transférable à d’autres configurations, par exemple l’importation et l’exportation vers des bases de données spatiales.\nUne question plus spécifique du point de vue de R est “pourquoi utiliser le paquet sf alors que sp est déjà éprouvé” ?\nIl existe de nombreuses raisons (liées notamment aux avantages du modèle des simple features) :lecture et écriture rapides des données ;amélioration des performances de représentation graphique ;les objets sf peuvent être traités comme des tableaux de données dans la plupart des opérations ;les noms des fonctions sf sont relativement cohérents et intuitifs (tous commencent par st_) ;les fonctions sf peuvent être combinées à l’aide de l’opérateur %>% et fonctionnent bien avec la collection tidyverse des paquets R.L’intégration de sf pour les paquets tidyverse est illustrée avec la fonction de lecture des données géographiques vectorisées: read_sf().\nAu contraire de la fonction st_read() qui va retourner les attributs dans les classes de base R data.frame (et affiche un message de compte rendu plus complet qui dans l’extrait de code ci dessous été omis) la fonction read_sf() va retourner un tidyverse tibble.\nVous en trouvez la démonstration ci-dessous (voir la section ?? sur la lecture et l’écriture des données géographiques vectorielles avec R) :Comme illusté dans le Chapitre 3, montrant la manipulation d’objets `sf avec le tidyverse, sf est désormais la bibliothèquee de référence pour l’analyse des données vectorielles spatiales dans R (sans oublier l’écosystème des paquets spatstat qui fournit de nombreuses fonctions pour les statistiques spatiales).\nDe nombreux paquets populaires reposent sur sf, comme le montre l’augmentation de sa popularité en termes de nombre de téléchargements par jour, comme indiqué dans la section 1.4 du chapitre précédent.\nLa transition de paquets et de chaînes de processus reposant sur les anciens paquets rgeos et rgdal prends du temps (Bivand 2021), mais le processus été acceleré par le sentiments d’urgence par les messages indiquant qu’ils “seraient indisponibles à partir de fin 2023”.\nCela signifie que quiconque utilisant encore ces paquets se doit de “passer aux fonctions de sf/stars/terra pour utiliser GDAL et PROJ le plus rapidement possible.”.En d’autres termes, sf est à l’épreuve du futur mais sp ne l’est pas.\nPour les workflow qui dépendent de l’ancienne classe Spatial, les objets sf peuvent être convertis depuis et vers la classe Spatial du paquet sp comme suit :","code":"\nnc_dfr = st_read(system.file(\"shape/nc.shp\", package = \"sf\"))\n#> Reading layer `nc' from data source \n#>   `/usr/local/lib/R/site-library/sf/shape/nc.shp' using driver `ESRI Shapefile'\n#> Simple feature collection with 100 features and 14 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -84.3 ymin: 33.9 xmax: -75.5 ymax: 36.6\n#> Geodetic CRS:  NAD27\nnc_tbl = read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\nclass(nc_dfr)\n#> [1] \"sf\"         \"data.frame\"\nclass(nc_tbl)\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\nlibrary(sp)\nworld_sp = as(world, \"Spatial\") # de sf à sp\n# sp functions ...\nworld_sf = st_as_sf(world_sp)           # de sp à sf"},{"path":"spatial-class.html","id":"basic-map","chapter":"2 La donnée géographique dans R","heading":"2.2.3 Réalisation rapide de cartes","text":"Des premiers jets de cartes peuvent être crées dans sf avec plot().\nPar défaut, cela crée un graphique avec de multiple encarts (comme spplot() de sp), un encart pour chaque variable de l’objet, comme illustré dans le panneau de gauche de la Figure 2.4.\nUne légende ou “clé” avec une couleur continue est produite si l’objet à tracer une seule variable (voir l’encart de droite).\nLes couleurs peuvent également être définies avec l’argument col =, bien que cela ne permette pas de créer une palette continue ou une légende.\n\nFIGURE 2.4: Cartographie avec sf, avec plusieurs variables (gauche) ou une seule (droite).\nLes graphiques sont ajoutés en tant que couches aux images existantes en ajoutant dans la fonction l’argument add = TRUE.9\nPour illustrer cela et donner un avant-goût du contenu des chapitres 3 et ?? sur les attributs et les opérations sur les données spatiales, l’extrait de code suivant combine des pays d’Asie :Ainsi, nous pouvons maintenant dessiner le continent asiatique sur une carte du monde.\nNotez que le premier graphique ne doit avoir qu’un seul encart pour que add = TRUE fonctionne.\nSi le premier graphique une légende, reset = FALSE doit être utilisé (résultat non montré) :L’ajout de couches de cette manière peut être utilisé pour vérifier la correspondance géographique entre les couches :\nla fonction plot() est rapide à exécuter et nécessite peu de lignes de code, mais ne permet pas de créer des cartes interactives avec une large gamme d’options.\nPour la réalisation de cartes plus poussées, nous recommandons l’utilisation de paquets de visualisation spécifiques tels que tmap (voir le chapitre ??).Il y plusieurs façons de modifier les cartes avec la méthode plot() de sf.\nComme sf étend les méthodes de base de R, les arguments de plot() tels que main = (qui spécifie le titre de la carte) fonctionnent avec les objets sf (voir ?graphics::plot et ?par).10\n\nLa figure 2.5 illustre cette flexibilité en superposant sur une carte du monde des cercles dont les diamètres (définis avec l’argument cex =) représentent les populations des pays.\nUne version non projetée de cette figure peut être créée avec les commandes suivantes (voir les exercices à la fin de ce chapitre et le script 02-contplot.R 2.5):\nFIGURE 2.5: Pays coloriés par continent et leur population en 2015 (cercles proportionnels à la population).\nLe code ci-dessus utilise la fonction st_centroid() pour convertir un type de géométrie (polygones) en un autre (points) (voir chapitre ??), dont la représentation varie en fonction de l’argument cex.\nLa méthode plot de sf possède également des arguments spécifiques aux données géographiques. expandBB, par exemple, peut être utilisé pour dessiner un objet sf dans son contexte :\nelle prend un vecteur de quatre nombres qui étend la boîte de délimitation de la carte par rapport à zéro en suivant l’ordre : bas, gauche, haut, droite.\nDans le programme suivant, ce paramètre est utilisé pour représenter l’Inde et ses gigantesques voisins asiatiques, en mettant l’accent sur la Chine à l’est 2.6 (voir les ci-dessous sur l’ajout de texte aux graphiques) :\nFIGURE 2.6: L’Inde et ses pays voisins, exemple d’utilisation du paramètre expandBB.\nNotez l’utilisation de [0] pour ne garder que la colonne de géométrie et de lwd pour mettre l’accent sur l’Inde.\nLa prochaine section ?? présente d’autres techniques de visualisation permettant de représenter une gamme de types de géométrie.","code":"\nplot(world[3:6])\nplot(world[\"pop\"])\nworld_asia = world[world$continent == \"Asia\", ]\nasia = st_union(world_asia)\nplot(world[\"pop\"], reset = FALSE)\nplot(asia, add = TRUE, col = \"red\")\nplot(world[\"continent\"], reset = FALSE)\ncex = sqrt(world$pop) / 10000\nworld_cents = st_centroid(world, of_largest = TRUE)\nplot(st_geometry(world_cents), add = TRUE, cex = cex)\nindia = world[world$name_long == \"India\", ]\nplot(st_geometry(india), expandBB = c(0, 0.2, 0.1, 1), col = \"gray\", lwd = 3)\nplot(world_asia[0], add = TRUE)"},{"path":"spatial-class.html","id":"geometry","chapter":"2 La donnée géographique dans R","heading":"2.2.4 Les types de géométries","text":"Les géométries sont les éléments de base des simples features.\nCes derniers peuvent prendre dans R l’un des 18 types de géométrie pris en charge par le paquet sf.\n\n\nDans ce chapitre, nous nous concentrerons sur les sept types les plus couramment utilisés : POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON et GEOMETRYCOLLECTION.\nLa liste complète des types d’éléments possibles est disponible dans le manuel de PostGIS.En général, le well-known binary (WKB) ou le well-known text (WKT) sont les codages standard pour les géométries simples.\n\n\n\nLes WKB sont généralement représentés par des chaînes hexadécimales facilement lisibles par les ordinateurs.\nC’est pourquoi les SIG et les bases de données spatiales l’utilisent pour transférer et stocker des objets géométriques.\nLe WKT, quant à lui, est une description de balisage textuel lisible par l’homme pour des simples features.\nLes deux formats sont échangeables, et si nous en présentons un, nous choisirons naturellement la représentation WKT.La base de chaque type de géométrie est le point.\nUn point est simplement une coordonnée dans un espace 2D, 3D ou 4D (cf. vignette(\"sf1\") pour plus d’informations). Un exemple est disponible sur le second panneau de la figure 2.7:\nPOINT (5 2)\nUne linestring, ligne, est une séquence de points avec une ligne droite reliant ces points, par exemple (cf. le panneau central de la figure 2.7) :LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)Un polygone est une séquence de points qui forment un anneau fermé, sans intersection.\nFermé signifie que le premier et le dernier point d’un polygone ont les mêmes coordonnées (cf. le panneau de droite de la figure 2.7).11\nPolygone sans anneau intérieur: POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\nFIGURE 2.7: Exemple de géometries de point, ligne et polygone.\nJusqu’à présent, nous avons créé des géométries avec une seule entité géométrique par élément.\nToutefois, sf permet également l’existence de plusieurs géométries au sein d’une même entité (d’où le terme “collection de géométries”) en utilisant la version “multi” de chaque type de géométrie :\nMultipoint: MULTIPOINT (5 2, 1 3, 3 4, 3 2)Multilinestring: MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))Multipolygon: MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2)))\nFIGURE 2.8: Examples de multi* geometries.\nEnfin, une collection de géométries peut contenir n’importe quelle combinaison de géométries, y compris des (multi)points et des lignes (voir figure 2.9) :\nGeometry collection: GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))\nFIGURE 2.9: Exemple de collection de géometrie.\n","code":""},{"path":"spatial-class.html","id":"sf","chapter":"2 La donnée géographique dans R","heading":"2.2.5 La classe sf","text":"Les Simple features sont composés de deux parties principales : les géométries et les attributs non géographiques.\nLa figure 2.10 montre comment un objet sf est créé – les géométries proviennent d’un objet sfc, tandis que les attributs sont pris dans un data.frame ou un tibble.\nLes sections 2.2.6 et 2.2.7 reprennent la création de géometries sf à partir de rien.\nFIGURE 2.10: Différentes étapes de construction des objets sf.\nLes attributs non géographiques permettent la représentation du nom de l’entité ou d’autres attributs, mesures, appartenance à des groupes et autres.\n\nPour l’illustrer nous allons représenter une température de 25°C à Londres le 21 juin 2017.\nCet exemple à une géométrie (les coordonnées) et trois attributs de trois classes différentes (le nom, la température et la date).12\nLes objets de la classe sf représentent de telles données en combinant les attributs (data.frame) avec la colonne de géométrie simple feature (sfc).\nIls sont créés avec st_sf(), comme l’illustre le code ci-dessous, créant l’exemple londonien :Que s’est-il passé ? Premièrement, les coordonnés ont été utilisées pour créer la simple feature geometry (sfg).\nDeuxièmement, la géométrie été convertie en une colonne de type simple feature (sfc), avec un SCR.\nTroisièmement, les attributs ont été stockés dans un data.frame, qui été combiné avec l’objet sfc avec st_sf().\nLe résultat est un objet sf, comme montré ci-dessous (une partie de la sortie de code est omise) :Le résultat montre que les objets sf ont en fait deux classes informatiques, sf et data.frame.\nLes Simple features sont simplement des tableaux de données mais avec un attribut spatial stocké dans une colonne de type liste, souvent nommée geometry, comme décrit dans la section ??.\nCette dualité est au coeur du concept de Simple features:\nla plupart du temps un objet sf peut être traité comme un data.frame et se comporté comme tel.\nLes Simple features sont, par essence, des tableaux de données avec une extension spatiale.","code":"\nlnd_point = st_point(c(0.1, 51.5))                 # objet sfg\nlnd_geom = st_sfc(lnd_point, crs = 4326)           # objet sfc\nlnd_attrib = data.frame(                           # objet data.frame\n  name = \"London\",\n  temperature = 25,\n  date = as.Date(\"2017-06-21\")\n  )\nlnd_sf = st_sf(lnd_attrib, geometry = lnd_geom)    # objet sf\nlnd_sf\n#> Simple feature collection with 1 features and 3 fields\n#> ...\n#>     name temperature       date         geometry\n#> 1 London          25 2017-06-21 POINT (0.1 51.5)\nclass(lnd_sf)\n#> [1] \"sf\"         \"data.frame\""},{"path":"spatial-class.html","id":"sfg","chapter":"2 La donnée géographique dans R","heading":"2.2.6 Simple feature geometries (sfg)","text":"La classe sfg représente les différents types de géométrie simple feature dans R : point, ligne, polygone (et leurs équivalents “multi”, comme les multipoints) ou collection de géométries.\nEn général, la tâche fastidieuse de création de géométries vous est épargnée car vous pouvez simplement importer un fichier spatial déjà existant.\nCependant, il existe un ensemble de fonctions permettant de créer des objets géométriques simple feature (sfg) à partir de zéro si nécessaire.\nLes noms de ces fonctions sont simples et cohérents, ils commencent tous par le préfixe st_ et se terminent par le nom du type de géométrie en lettres minuscules :Un point : st_point()Une ligne : st_linestring()Un polygone: st_polygon()Un multipoint: st_multipoint()Une multiligne : st_multilinestring()Un multipolygone : st_multipolygon()Une collection de géométries : st_geometrycollection()Les objets sfg peuvent être créés à partir de trois de types de données de R:Un vecteur numérique: un point uniqueUn matrice: un ensemble de points, où chaque ligne représente un point, un multipoint ou une ligneUne liste: une collection d’objets comme des matrices, des multilignes ou des collections de géométries.La fonction st_point() crée un point à partir de vecteurs numériques :Les sorties montrent que les types de points XY (coordonnées 2D), XYZ (coordonnées 3D) et XYZM (3D avec une variable supplémentaire, généralement la précision de mesure) sont créés à partir de vecteurs de longueur 2, 3 et 4, respectivement.\nLe type XYM doit être spécifié en utilisant l’argument dim (qui est l’abréviation de dimension).En revanche, vous devez utiliser des matrices dans le cas des objets multipoints (st_multipoint()) et ligne (st_linestring()) :Enfin, vous devez utiliser les listes pour la création de multilignes, de (multi-)polygones et de collections de géométries :","code":"\nst_point(c(5, 2))                 # point en XY\n#> POINT (5 2)\nst_point(c(5, 2, 3))              # point en XYZ\n#> POINT Z (5 2 3)\nst_point(c(5, 2, 1), dim = \"XYM\") # point en XYM\n#> POINT M (5 2 1)\nst_point(c(5, 2, 3, 1))           # point en XYZM\n#> POINT ZM (5 2 3 1)\n# la fonction rbind simplifie la création de matrices\n## MULTIPOINT\nmultipoint_matrix = rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))\nst_multipoint(multipoint_matrix)\n#> MULTIPOINT ((5 2), (1 3), (3 4), (3 2))\n## LIGNE\nlinestring_matrix = rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2))\nst_linestring(linestring_matrix)\n#> LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\n## POLYGONE\npolygon_list = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\nst_polygon(polygon_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\n## POLYGONE avec un trou\npolygon_border = rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))\npolygon_hole = rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4))\npolygon_with_hole_list = list(polygon_border, polygon_hole)\nst_polygon(polygon_with_hole_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))\n## MULTILIGNE\nmultilinestring_list = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nst_multilinestring((multilinestring_list))\n#> MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))\n## MULTIPOLYGONE\nmultipolygon_list = list(list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))),\n                         list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))))\nst_multipolygon(multipolygon_list)\n#> MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))\n## COLLECTIONS DE GEOMETRIES\ngemetrycollection_list = list(st_multipoint(multipoint_matrix),\n                              st_linestring(linestring_matrix))\nst_geometrycollection(gemetrycollection_list)\n#> GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2),\n#>   LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))"},{"path":"spatial-class.html","id":"sfc","chapter":"2 La donnée géographique dans R","heading":"2.2.7 Simple feature columns (sfc)","text":"Un objet sfg ne contient qu’un seul élément géométrique simple feature.\nUne colonne de géométrie *simple feature (sfc) est une liste d’objets sfg, qui peut en outre contenir des informations sur le système de référence des coordonnées utilisé.\nPar exemple, pour combiner deux simples features en un seul objet avec deux entités, nous pouvons utiliser la fonction st_sfc().\n\nC’est important car sfc va correspondre à la colonne de géométrie dans les tableaux de données sf** :Dans la plupart des cas, un objet sfc contient des objets du même type géométrique.\nPar conséquent, lorsque nous convertissons des objets sfg de type polygone en une colonne géométrique simple feature, nous obtenons également un objet sfc de type polygone, ce qui peut être vérifié avec st_geometry_type().\nDe même, une colonne géométrique de multilignes donnera un objet sfc de type multiligne :C’est aussi possible de créer un objet sfc à partir d’objets sfg de géométries différentes.Comme indiqué précédemment, les objets sfc peuvent également stocker de l’information sur le système de coordonnées et de référence (SCR).\nLa valeur par défaut est NA (Available) et elle peut être vérifiée avec st_crs() :Toutes les géométries des objets sfc doivent avoir le même SCR.\nUn SCR peut être spécifié avec l’argument crs de st_sfc() (ou st_sf()), il prend un identifiant SCR fourni sous forme de chaîne de texte, comme crs = \"EPSG:4326\" (voir la section ?? pour détails et mieux comprendre ce que cela signifie)","code":"\n# POINT sfc\npoint1 = st_point(c(5, 2))\npoint2 = st_point(c(1, 3))\npoints_sfc = st_sfc(point1, point2)\npoints_sfc\n#> Geometry set for 2 features \n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 2 xmax: 5 ymax: 3\n#> CRS:           NA\n#> POINT (5 2)\n#> POINT (1 3)\n# sfc POLYGON\npolygon_list1 = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\npolygon1 = st_polygon(polygon_list1)\npolygon_list2 = list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2)))\npolygon2 = st_polygon(polygon_list2)\npolygon_sfc = st_sfc(polygon1, polygon2)\nst_geometry_type(polygon_sfc)\n#> [1] POLYGON POLYGON\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# sfc MULTILINESTRING\nmultilinestring_list1 = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nmultilinestring1 = st_multilinestring((multilinestring_list1))\nmultilinestring_list2 = list(rbind(c(2, 9), c(7, 9), c(5, 6), c(4, 7), c(2, 7)), \n                            rbind(c(1, 7), c(3, 8)))\nmultilinestring2 = st_multilinestring((multilinestring_list2))\nmultilinestring_sfc = st_sfc(multilinestring1, multilinestring2)\nst_geometry_type(multilinestring_sfc)\n#> [1] MULTILINESTRING MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# GEOMETRIE sfc \npoint_multilinestring_sfc = st_sfc(point1, multilinestring1)\nst_geometry_type(point_multilinestring_sfc)\n#> [1] POINT           MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\nst_crs(points_sfc)\n#> Coordinate Reference System: NA\n# Paramètrer le SCR avec un identifiant 'EPSG':\npoints_sfc_wgs = st_sfc(point1, point2, crs = \"EPSG:4326\")\nst_crs(points_sfc_wgs) # indique le SCR (seulement les 4 premières lignes sont montrées)\n#> Coordinate Reference System:\n#>   User input: EPSG:4326 \n#>   wkt:\n#> GEOGCRS[\"WGS 84\",\n#> ..."},{"path":"spatial-class.html","id":"le-paquet-sfheaders","chapter":"2 La donnée géographique dans R","heading":"2.2.8 le paquet sfheaders","text":"sfheaders est un paquet pour R qui accélère la construction, la conversion et la manipulation d’objets sf (Cooley 2020).\nIl se focalise sur la construction rapide d’objets sf à partir de vecteurs, matrices et tableaux de données, sans dépendre de la bibliothèque sf ; en exposant son code C++ sous-jacent à travers des fichiers d’en-tête (d’où le nom, sfheaders).\nCette approche permet à d’autres de l’étendre en utilisant un code compilé et rapide.\nChaque fonction de base de sfheaders une implémentation C++ correspondante, comme décrit dans la vignette Cpp.\nPour la plupart des gens, les fonctions R seront plus que suffisantes pour bénéficier de la vitesse de calcul du paquet.\nsfheaders été développé séparément de sf, mais vise à être totalement compatible, en créant des objets sf valides du type décrit dans les sections précédentes.Les cas le plus simple d’utilisation de sfheaders sont présentés dans les morceaux de code ci-dessous avec des exemples de construction d’objets sfg, sfc, et sf :un vecteur converti en sfg_POINT;une matrice convertie en sfg_LINESTRING;un tableau de données converti en sfg_POLYGON.Nous allons commencer par créer l’objet sfg le plus simple possible, une seule paire de coordonnées, assignée à un vecteur nommé v :L’exemple ci-dessus montre comment l’objet sfg v_sfg_sfh est affiché lorsque sf n’est pas chargé, démontrant ainsi sa structure sous-jacente.\nLorsque sf est chargé (comme c’est le cas ici), le résultat de la commande ci-dessus est indiscernable des objets sf :Les exemples suivants montrent comment sfheaders crée des objets sfg à partir de matrices et de tableaux de données :En réutilisant les objets v, m, et df, nous pouvons également construire des colonnes de géométrie simple feature (sfc) comme suit (sorties non montrées) :De même, les objets sf sont crées comme suis:Dans chacun de ces exemples, le SCR (système de coordonnées et de référence) n’est pas défini.\nSi vous prévoyez d’effectuer des calculs ou des opérations géométriques à l’aide des fonctions sf, nous vous recommandons de définir le SCR (voir le chapitre ?? pour plus de détails) :sfheaders est aussi une bonne option pour “déconstruire” et “reconstruire” les objets sf, c’est-à-dire convertir les colonnes géométriques en tableaux de données contenant les coordonnées de chaque sommet (vertex) et les identifiants de chaque éléments géométriques (et d’éventuels géométrie multiples).\nIl est rapide et fiable pour “passer” des colonnes géométriques vers différents types, un sujet traité dans le chapitre ??.\nDes tests, dans la documentation du paquet et dans le code de test développé pour ce livre, montrent qu’il est beaucoup plus rapide que le paquet sf pour de telles opérations.","code":"\nv = c(1, 1)\nv_sfg_sfh = sfheaders::sfg_point(obj = v)\nv_sfg_sfh # affichage sans sf chargé\n#>      [,1] [,2]\n#> [1,]    1    1\n#> attr(,\"class\")\n#> [1] \"XY\"    \"POINT\" \"sfg\" \nv_sfg_sf = sf::st_point(v, c(1, 2))\nprint(v_sfg_sf) == print(v_sfg_sfh)\n#> POINT (1 1)\n#> POINT (1 1)\n#> [1] TRUE\n# matrices\nm = matrix(1:8, ncol = 2)\nsfheaders::sfg_linestring(obj = m)\n#> LINESTRING (1 5, 2 6, 3 7, 4 8)\n# data.frames\ndf = data.frame(x = 1:4, y = 4:1)\nsfheaders::sfg_polygon(obj = df)\n#> POLYGON ((1 4, 2 3, 3 2, 4 1, 1 4))\nsfheaders::sfc_point(obj = v)\nsfheaders::sfc_linestring(obj = m)\nsfheaders::sfc_polygon(obj = df)\nsfheaders::sf_point(obj = v)\nsfheaders::sf_linestring(obj = m)\nsfheaders::sf_polygon(obj = df)\ndf_sf = sfheaders::sf_polygon(obj = df)\nst_crs(df_sf) = \"EPSG:4326\""},{"path":"spatial-class.html","id":"s2","chapter":"2 La donnée géographique dans R","heading":"2.2.9 géométrie sphérique avec S2","text":"Les moteurs de géométrie sphérique sont basés sur le fait que la terre est ronde alors que les procédures mathématiques simples de géocomputation, telles que le calcul d’une ligne droite entre deux points ou de l’aire délimitée par un polygone, supposent des géométries planes (projetées).\nDepuis la version 1.0.0 de sf, R prend en charge les opérations de géométrie sphérique “d’emblée”, grâce à son interface avec le moteur de géométrie sphérique S2 de Google, via le paquet l’interfaçant s2.\nS2 est peut-être mieux connu comme un exemple de système de grille globale discrète (DGGS).\nUn autre exemple est l’indice spatial hiérarchique hexagonal global H3 (Bondaruk, Roberts, Robertson 2020).Bien que potentiellement utile pour décrire des lieux n’importe où sur la Terre en utilisant des chaînes de caractères telles que e66ef376f790adf8a5af7fca9e6e422c03c9143f, le principal avantage de l’interface de sf avec S2 est l’intégration de fonctions de calculs tels que les calculs de distance, de tampon (buffer) et de surface. Ils sont décrit dans la documentation intégrée de sf qui peut être ouverte avec la commande vignette(\"sf7\").sf peut fonctionner sur deux modes par rapport à S2 : activé et désactivé.\nPar défaut, le moteur de géométrie S2 est activé, comme peut le vérifier avec la commande suivante :Un exemple des conséquences de la désactivation du moteur de géométrie est montré ci-dessous, en créant des tampons autour de l’objet india créé plus tôt dans le chapitre (notez les avertissements émis lorsque S2 est désactivé)\nFIGURE 2.11: Exemple des conséquences de la désactivation du moteur géométrique S2. Les deux représentations d’un tampon autour de l’Inde ont été créées avec la même commande, mais l’objet polygone violet été créé avec S2 activé, ce qui donné un tampon de 1 m. Le polygone vert clair, plus grand, été créé avec S2 désactivé, ce qui donné un tampon inexacte avec des degrés en longitude/latitude.\nDans ce livre, nous supposerons que S2 est activé, sauf indication contraire.\nActivez-le à nouveau avec la commande suivante.","code":"\nsf_use_s2()\n#> [1] TRUE\nindia_buffer_with_s2 = st_buffer(india, 1)\nsf_use_s2(FALSE)\n#> Spherical geometry (s2) switched off\nindia_buffer_without_s2 = st_buffer(india, 1)\n#> Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle =\n#> endCapStyle, : st_buffer does not correctly buffer longitude/latitude data\n#> dist is assumed to be in decimal degrees (arc_degrees).\nsf_use_s2(TRUE)\n#> Spherical geometry (s2) switched on"},{"path":"spatial-class.html","id":"données-raster","chapter":"2 La donnée géographique dans R","heading":"2.3 Données Raster","text":"Le modèle de données raster représente le monde à l’aide d’une grille continue de cellules (souvent aussi appelées pixels ; Figure 2.12:).\nCe modèle de données fait souvent référence à des grilles dites régulières, dans lesquelles chaque cellule une taille identique et constante - et nous nous concentrerons uniquement sur les grilles régulières dans cet ouvrage.\nCependant, plusieurs autres types de grilles existent, notamment les grilles tournées, cisaillées, rectilignes et curvilignes (voir le chapitre 1 de Pebesma Bivand (2022) ou le chapitre 2 de Tennekes Nowosad (2022)).Un raster se compose généralement d’un en-tête\net d’une matrice (avec des lignes et des colonnes) représentant des cellules équidistantes (souvent aussi nommées pixels; Figure 2.12:).)13\nL’en-tête du raster définit le système de coordonnées et références, l’étendue et l’origine.\n\n\nL’origine (ou point de départ) est souvent la coordonnée du coin inférieur gauche de la matrice (LE paquet terra utilise toutefois le coin supérieur gauche, par défaut (Figure 2.12:B)).\nL’en-tête définit l’étendue via le nombre de colonnes, le nombre de lignes et la résolution de la taille des cellules.\nAinsi, en partant de l’origine, nous pouvons facilement accéder à chaque cellule et la modifier, soit en utilisant l’ID d’une cellule (Figure 2.12:B), soit en spécifiant explicitement les lignes et les colonnes.\nCette représentation matricielle évite de stocker explicitement les coordonnées des quatre points d’angle (en fait, elle ne stocke qu’une seule coordonnée, à savoir l’origine) de chaque coin de cellule, comme ce serait le cas pour les polygones vectoriels rectangulaires.\nGrâce à cela et à l’algèbre matricielle (section ??), le traitement raster est beaucoup plus efficace et rapide que le traitement des données vectorielles.\nCependant, contrairement aux données vectorielles, la cellule d’une couche raster ne peut contenir qu’une seule valeur.\nCette valeur peut être numérique ou catégorique (Figure 2.12:C).\nFIGURE 2.12: Données raster types: () identifiant des pixels, (B) Valeur des pixels, (C) une carte raster colorisée.\nLes rasters représentent généralement des phénomènes continus tels que l’élévation, la température, la densité de population ou des données spectrales.\nLes variables discrètes telles que les classes de sol ou de couverture terrestre peuvent également être représentées dans le modèle de données raster.\nCes deux utilisations sont illustrées dans la figure 2.13, elle montre comment les limites des caractéristiques discrètes peuvent devenir floues dans les ensembles de données matricielles.\nSelon la nature de l’application, les représentations vectorielles des caractéristiques discrètes peuvent être plus adaptées.\nFIGURE 2.13: Exemples de rasters pour des variables continues et catégorielles.\n","code":""},{"path":"spatial-class.html","id":"les-paquets-de-r-pour-travailler-avec-des-rasters","chapter":"2 La donnée géographique dans R","heading":"2.3.1 Les paquets de R pour travailler avec des rasters","text":"Au cours des deux dernières décennies, plusieurs paquets permettant de lire et de traiter des ensembles de données matricielles ont été développés.\nComme indiqué dans la section 1.5, le principal d’entre eux était raster. Il conduit à un changement radical dans les capacités de traitement des rasters avec R lorsqu’il été lancé en 2010 et il dominé ce segment jusqu’au développement de terra et stars.\nLes deux paquets développés plus récemment offrent des fonctions puissantes et performantes pour travailler avec des jeux de données raster et ils ont d’important recoupement entre leurs cas d’usages.\nDans ce livre, nous nous concentrons sur terra, qui remplace raster, plus ancien et (dans la plupart des cas) plus lent.\nAvant de découvrir le fonctionnement du système de classes de terra, cette section décrit les similitudes et les différences entre terra et stars ; ces connaissances aideront à décider lequel est le plus approprié dans différentes situations.Tout d’abord, terra se concentre sur le modèle de données raster le plus courant (grilles régulières), tandis que stars permet également de stocker des modèles moins populaires (notamment des grilles régulières, tournées, cisaillées, rectilignes et curvilignes).\nAlors que terra gère généralement des rasters à une ou plusieurs couches14, le paquet stars fournit des moyens de stocker des cubes de données raster – un objet raster avec de nombreuses couches (par exemple, des bandes), pour de nombreux moments dans le temps (par exemple, des mois), et de nombreux attributs (par exemple, le type de capteur et le type de capteur B).\nPremièrement, il est important de noter que dans les deux paquets, toutes les couches ou éléments d’un cube de données doivent avoir les mêmes dimensions spatiales et la même étendue.\nDeuxièmement, les deux paquets permettent soit de lire toutes les données raster en mémoire, soit de lire uniquement leurs métadonnées, ce qui est généralement effectué automatiquement en fonction de la taille du fichier d’entrée.\nCependant, ils stockent raster de manière très différente.\nterra est basé sur du code C++ et utilise principalement des pointeurs C++.\nstars stocke les valeurs sous forme de listes de tableaux pour les plus petits rasters ou juste un chemin de fichier pour les plus grands.\nTroisièmement, les fonctions de stars sont étroitement liées aux objets et fonctions vectorielles de sf, alors que terra utilise sa propre classe d’objets pour les données vectorielles, à savoir SpatVector.\nQuatrièmement, les deux paquets approchent différemment la façon dont leurs fonctions agissent sur leurs objets.\nLe paquet terra s’appuie principalement sur un grand nombre de fonctions intégrées, où chaque fonction un spécifique (par exemple, le rééchantillonnage ou le recadrage).\nDe son coté stars utilise quelques fonctions intégrées (généralement avec des noms commençant par st_) avec en complément de ses propres méthodes pour les fonctions de R existantes (par exemple, split() ou aggregate()), et des méthodes pour les fonctions de dplyr (par exemple, filter() ou slice()).Il est important de noter qu’il est facile de convertir des objets de terra en stars (en utilisant st_as_stars()) et inversement (en utilisant rast()).\nNous vous encourageons également à lire Pebesma Bivand (2022) pour l’introduction la plus complète au paquet stars.","code":""},{"path":"spatial-class.html","id":"une-introduction-à-terra","chapter":"2 La donnée géographique dans R","heading":"2.3.2 Une introduction à terra","text":"Le paquet terra prend en charge les objets raster dans R.\nComme son prédécesseur raster (créé par le même développeur, Robert Hijmans), il fournit un ensemble complet de fonctions pour créer, lire, exporter, manipuler et traiter des jeux de données rasters.\nLes fonctionnalités de terra sont en grande partie les mêmes que celles du paquetage raster, plus mature, mais il existe quelques différences : Les fonctions terra sont généralement plus efficientes en calcul que les équivalents raster.\n\nD’autre part, le système de classes de raster est populaire et utilisé par de nombreux autres paquets.\nVous pouvez passer sans problème d’un type d’objet à l’autre pour assurer la compatibilité avec les anciens scripts et paquets, par exemple avec les fonctions raster(), stack() et brick() du paquet raster (cf. le chapitre précédent pour en savoir plus sur l’évolution des paquets R pour travailler avec des données géographiques).En plus des fonctions de manipulation des données matricielles, terra fournit de nombreuses fonctions de bas niveau pouvant servir de base au développement de nouveaux outils pour travailler avec des jeux de données raster.\n\nterra vous permet également de travailler sur de grands jeux de données raster qui sont trop volumineux pour tenir dans la RAM.\nDans ce cas, terra offre la possibilité de diviser l’image raster en petits morceaux et de les traiter de manière itérative au lieu de charger un fichier entier dans la RAM.Pour l’illustration des concepts terra, nous utiliserons des jeux de données de la spDataLarge.\nIl s’agit de quelques objets raster et d’un objet vectoriel couvrant une zone du parc national de Zion (Utah, USA).\nPar exemple, srtm.tif est un modèle numérique d’élévation de cette zone (pour plus de détails, voir sa documentation ?srtm).\nTout d’abord, créons un objet SpatRaster nommé my_rast :En tapant le nom du raster dans la console, obtient l’en-tête du raster (dimensions, résolution, étendue, CRS) et quelques informations supplémentaires (classe, source de données, résumé des valeurs du raster) :Des fonctions dédiées renseignent chaque composant : dim(my_rast) renvoie le nombre de lignes, de colonnes et de couches ; ncell() le nombre de cellules (pixels) ; res() la résolution spatiale ; ext() son étendue spatiale ; et crs() son système de référence de coordonnées (la reprojection matricielle est traitée dans la section ??).\ninMemory() indique si le raster est stocké en mémoire vive ou sur disque.help(\"terra-package\") renvoie une liste complète de toutes les fonctions terra disponibles.","code":"\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = rast(raster_filepath)\nclass(my_rast)\n#> [1] \"SpatRaster\"\n#> attr(,\"package\")\n#> [1] \"terra\"\nmy_rast\n#> class       : SpatRaster \n#> dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.000833, 0.000833  (x, y)\n#> extent      : -113, -113, 37.1, 37.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source      : srtm.tif \n#> name        : srtm \n#> min value   : 1024 \n#> max value   : 2892"},{"path":"spatial-class.html","id":"basic-map-raster","chapter":"2 La donnée géographique dans R","heading":"2.3.3 Réalisation de cartes de base","text":"Comme le paquet sf, terra fournit également des méthodes plot() pour ses propres classes.\n\nFIGURE 2.14: Basic raster plot.\nIl existe plusieurs autres approches pour représenter des données raster dans R qui sortent du cadre de cette section, notamment :la fonction plotRGB() du paquet terra pour créer une composition colorée rouge-vert-bleu (RGB) basée sur trois couches dans un objet SpatRaster.Des paquets tels que tmap pour créer des cartes statiques et interactives d’objets rasters et vectoriels (voir le chapitre ??)D’autres fonctions, par exemple levelplot() du paquet rasterVis, pour créer des vignettes, une technique courante pour visualiser les changements dans le temps.","code":"\nplot(my_rast)"},{"path":"spatial-class.html","id":"raster-classes","chapter":"2 La donnée géographique dans R","heading":"2.3.4 Les classes Raster","text":"La classe SpatRaster représente les rasters dans terra.\nLa façon la plus simple de créer un objet raster dans R est de lire un fichier raster à partir du disque ou d’un serveur (Section ??.\nLe paquet terra supporte de nombreux pilotes à l’aide de la bibliothèque GDAL.\nLes rasters provenant de fichiers ne sont généralement pas lus entièrement en RAM, à l’exception de leur en-tête et d’un pointeur vers le fichier lui-même.Les rasters peuvent aussi être créés à partir de zéro en utilisant la même fonction rast().\nCeci est illustré dans l’extrait de code suivant produisant en un nouvel objet SpatRaster.\nCe raster consiste en 36 cellules (6 colonnes et 6 lignes spécifiées par nrows et ncols) centrées autour du Méridien d’origine et de l’Équateur (voir les paramètres xmin, xmax, ymin et ymax).\nLe SCR par défaut des objets rasters est WGS84, mais peut être changé avec l’argument crs.\nCela signifie que l’unité de résolution est en degrés, que nous fixons à 0.5 (resolution).\nDes valeurs (vals) sont assignées à chaque cellule : 1 à la cellule 1, 2 à la cellule 2, et ainsi de suite.\nRappelez-vous : rast() remplit les cellules par rangées (contrairement à matrix()) en commençant par le coin supérieur gauche, ce qui signifie que la première rangée contient les valeurs 1 à 6, la seconde 7 à 12, etc.?rast permet de découvrir d’autre facons de créer des objets rasters.La classe SpatRaster gère également les couches multiples, qui correspondent généralement à un seul fichier satellite multispectral ou à une série temporelle de rasters.nlyr() fournit le nombre de couches stockées dans un objet SpatRaster :Pour les objets raster multi-couches, les couches peuvent être sélectionnées avec terra::subset().15.\nElle accepte un numéro de couche ou son nom comme second argument :L’opération inverse, qui consiste à combiner plusieurs objets SpatRaster en un seul, peut être réalisée à l’aide de la fonction c :","code":"\nsingle_raster_file = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_rast = rast(raster_filepath)\nnew_raster = rast(nrows = 6, ncols = 6, resolution = 0.5, \n                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                  vals = 1:36)\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\nmulti_rast\n#> class       : SpatRaster \n#> dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)\n#> resolution  : 30, 30  (x, y)\n#> extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\n#> coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \n#> source      : landsat.tif \n#> names       : landsat_1, landsat_2, landsat_3, landsat_4 \n#> min values  :      7550,      6404,      5678,      5252 \n#> max values  :     19071,     22051,     25780,     31961\nnlyr(multi_rast)\n#> [1] 4\nmulti_rast3 = subset(multi_rast, 3)\nmulti_rast4 = subset(multi_rast, \"landsat_4\")\nmulti_rast34 = c(multi_rast3, multi_rast4)"},{"path":"spatial-class.html","id":"crs-intro","chapter":"2 La donnée géographique dans R","heading":"2.4 Système de Coordonnés et de Réferences géographiques et projetés","text":"\nLes types de données spatiales vectorielles et rasters partagent des concepts intrinsèques aux données spatiales.\nLe plus fondamental d’entre eux est peut-être le système de référence des coordonnées (SCR), qui définit la manière dont les éléments spatiaux des données se rapportent à la surface de la Terre (ou d’autres corps).\nLes CRS sont soit géographiques, soit projetés, comme nous l’avons présenté au début de ce chapitre (voir Figure 2.1).\nCette section reprend chaque type, posant ainsi les bases du chapitre ??, qui offre une plongée en profondeur dans la configuration, la transformation et l’interrogation des SCR.","code":""},{"path":"spatial-class.html","id":"système-de-référence-des-coordonnées","chapter":"2 La donnée géographique dans R","heading":"2.4.1 Système de référence des coordonnées","text":"\nLes systèmes de coordonnées géographiques identifient tout emplacement sur la surface de la Terre à l’aide de deux valeurs — la longitude et la latitude (voir le panneau gauche de la figure 2.16).\nLa longitude est la position dans la direction est-ouest en distance angulaire par rapport au plan du méridien d’origine.\nLa latitude est la distance angulaire au nord ou au sud du plan équatorial.\nLes distances dans les SCR géographiques ne sont donc pas mesurées en mètres.\nCela des conséquences importantes, comme le montre la section ??.La surface de la Terre dans les systèmes de coordonnées géographiques est représentée par une surface sphérique ou ellipsoïdale.\nLes modèles sphériques supposent que la Terre est une sphère parfaite d’un rayon donné. Ils ont l’avantage de la simplicité mais, en même temps, ils sont inexacts : la Terre n’est pas une sphère !\nLes modèles ellipsoïdaux sont définis par deux paramètres : le rayon équatorial et le rayon polaire.\nIls sont adaptés car la Terre est comprimée : le rayon équatorial est environ 11,5 km plus long que le rayon polaire (Maling 1992).16Les ellipsoïdes font partie d’un composant plus large des SCR : le datum.\nIl contient des informations sur l’ellipsoïde à utiliser et la relation précise entre les coordonnées cartésiennes et l’emplacement sur la surface de la Terre.\nIl existe deux types de datum — géocentrique (tel que WGS84) et local (tel que NAD83).\nVous pouvez voir des exemples de ces deux types de référentiels dans la figure 2.15.\nLes lignes noires représentent un * datum géocentrique, dont le centre est situé au centre de gravité de la Terre et n’est pas optimisé pour un emplacement spécifique.\nDans un datum référentiel*, représenté par une ligne pointillée violette, la surface ellipsoïdale est décalée pour s’aligner sur la surface à un endroit particulier.\nCela permet de prendre en compte les variations locales de la surface de la Terre, dues par exemple à de grandes chaînes de montagnes, dans un SCR local.\npeut le voir sur la figure 2.15, où le système de référence local est adapté à la région des Philippines, mais n’est pas aligné avec la majeure partie du reste de la surface de la planète.\nLes deux référentiels de la figure 2.15 sont placés au-dessus d’un géoïde - un modèle du niveau moyen des mers à l’échelle mondiale 17.\nFIGURE 2.15: Données géocentriques et géodésiques locales représentées sur un géoïde (en fausses couleurs et avec un facteur d’échelle de 10 000 pour l’exagération verticale). L’image du géoïde est adaptée du travail de Ince et al. (2019).\n","code":""},{"path":"spatial-class.html","id":"système-de-réference-projetées","chapter":"2 La donnée géographique dans R","heading":"2.4.2 Système de réference projetées","text":"\nTous les SCR projetés sont basés sur un SCR géographique, décrit dans la section précédente, et s’appuient sur des projections cartographiques pour convertir la surface tridimensionnelle de la Terre en valeurs d’abscisses et d’ordonnées (x et y) dans un SCR projeté.\nLes SRC projetés sont basés sur des coordonnées cartésiennes sur une surface implicitement plane (panneau de droite de la figure 2.16).\nIls ont une origine, des axes x et y, et une unité de mesure linéaire telle que le mètre.Cette transition ne peut se faire sans ajouter certaines déformations.\nPar conséquent, certaines propriétés de la surface de la Terre sont déformées au cours de ce processus, telles que la superficie, la direction, la distance et la forme.\nUn système de coordonnées projeté ne peut préserver qu’une ou deux de ces propriétés.\nLes projections sont souvent nommées en fonction de la propriété qu’elles préservent : la projection de surface égale préserve l’aire, la projection azimutale préserve la direction, la projection équidistante préserve la distance et la projection conforme préserve la forme locale.Il existe trois groupes principaux de types de projection : conique, cylindrique et plane (azimutale).\nDans une projection conique, la surface de la Terre est projetée sur un cône le long d’une seule ligne de tangence ou de deux lignes de tangence.\nLes distorsions sont minimisées le long des lignes de tangence et augmentent avec la distance à ces lignes dans cette projection.\nElle est donc le mieux adaptée aux cartes des zones de latitude moyenne.\nUne projection cylindrique représente la surface sur un cylindre.\nCette projection peut également être créée en touchant la surface de la Terre le long d’une seule ligne de tangence ou de deux lignes de tangence.\nLes projections cylindriques sont le plus souvent utilisées pour cartographier le monde entier.\nUne projection plane projette les données sur une surface plate en touchant le globe en un point ou le long d’une ligne de tangence.\nElle est généralement utilisée pour cartographier les régions polaires.\nsf_proj_info(type = \"proj\") donne une liste des projections disponibles supportées par la bibliothèque PROJ.Un résumé rapide des différentes projections, de leurs types, de leurs propriétés et de leur adéquation peut être trouvé dans “Map Projections” (1993) et sur https://www.geo-projections.com/.\nNous nous étendrons sur les SCR et expliquerons comment projeter d’un SCR à un autre dans le chapitre ??.\nPour l’instant, il suffit de savoir :Les systèmes de coordonnées sont un élément clé des objets géographiques.Il est important de savoir dans quel SCR se trouvent vos données, et s’il s’agit d’un système géographique (lon/lat) ou d’un système projeté (généralement en mètres), car cela des conséquences sur la façon dont R gère les opérations spatiales et géométriques.Les SCR des objets sf peuvent être interrogés avec la fonction st_crs(), les SCR des objets terra peuvent être interrogés avec la fonction crs().\nFIGURE 2.16: Exemples de systèmes de coordonnées géographiques (WGS 84 ; à gauche) et projetées (NAD83 / UTM zone 12N ; à droite) pour un type de données vectorielles.\n","code":""},{"path":"spatial-class.html","id":"unités","chapter":"2 La donnée géographique dans R","heading":"2.5 Unités","text":"Une caractéristique importante des SCR est qu’ils contiennent des informations sur les unités spatiales.\nDe toute évidence, il est essentiel de savoir si les mesures d’une maison sont en pieds ou en mètres, et il en va de même pour les cartes.\nIl est de bonne pratique cartographique d’ajouter une barre d’échelle ou un autre indicateur de distance sur les cartes afin de démontrer la relation entre les distances sur la page ou l’écran et les distances sur le terrain.\nDe même, il est important de spécifier formellement les unités dans lesquelles les données géométriques ou les cellules sont mesurées afin de fournir un contexte et de garantir que les calculs ultérieurs sont effectués dans ce contexte.Une nouvelle caractéristique des données géométriques dans les objets sf est qu’elles ont un support natif pour les unités.\nCela signifie que les calculs de distance, de surface et autres calculs géométriques dans sf renvoient des valeurs accompagnées d’un attribut units, défini par le paquet units (Pebesma, Mailund, Hiebert 2016).\nCeci est avantageux, car cela évite la confusion causée par les différentes unités (la plupart des SCR utilisent les mètres, certains les pieds) et fournit des informations sur la dimensionnalité.\nCeci est démontré dans le morceau de code ci-dessous, qui calcule la superficie du Luxembourg :\n\nLa sortie est en unités de mètres carrés (m2), montrant que le résultat représente un espace bidimensionnel.\nCette information, stockée sous forme d’attribut (que les lecteurs intéressés peuvent découvrir avec attributs(st_area(luxembourg))), peut alimenter des calculs ultérieurs qui utilisent des unités, comme la densité de population (nombre de personnes par unité de surface, typiquement par km2).\nLe fait de déclarer les unités permet d’éviter toute confusion.\nPour reprendre l’exemple du Luxembourg, si les unités n’étaient pas précisées, pourrait supposer à tort que les unités sont en hectares.\nPour traduire ce chiffre énorme en une taille plus digeste, il est tentant de diviser les résultats par un million (le nombre de mètres carrés dans un kilomètre carré)Cependant, le résultat est alors donné de manière incorrecte en mètres carrés.\nLa solution consiste à définir les unités correctes avec le paquet units :Les unités sont tout aussi importantes dans le cas des jeux de données raster.\nCependant, jusqu’à présent, sf est le seul paquet spatial qui supporte les unités, ce qui signifie que les personnes travaillant sur des données raster doivent aborder les changements d’unités d’analyse (par exemple, la conversion de la largeur des pixels des unités impériales aux unités décimales) avec précaution.\nL’objet my_rast (voir ci-dessus) utilise une projection WGS84 avec des degrés décimaux comme unités.\nPar conséquent, sa résolution est également donnée en degrés décimaux, mais il faut le savoir, puisque la fonction res() renvoie simplement un vecteur numérique.Si nous utilisions la projection UTM, les unités changeraient.Encore une fois, la commande res() renvoie un tableau numérique sans unité, ce qui nous oblige à savoir que l’unité de la projection UTM est le mètre.","code":"\nluxembourg = world[world$name_long == \"Luxembourg\", ]\nst_area(luxembourg) # nécessite le paquet s2 des récentes version de sf\n#> 2.41e+09 [m^2]\nst_area(luxembourg) / 1000000\n#> 2409 [m^2]\nunits::set_units(st_area(luxembourg), km^2)\n#> 2409 [km^2]\nres(my_rast)\n#> [1] 0.000833 0.000833\nrepr = project(my_rast, \"EPSG:26912\")\nres(repr)\n#> [1] 83.5 83.5"},{"path":"spatial-class.html","id":"ex2","chapter":"2 La donnée géographique dans R","heading":"2.6 Exercises","text":"E1. Utilisez summary() sur la colonne géométrie de l’objet de données world qui est inclus dans le paquet spData. Qu’en déduisez vous sur :Son type de géométrie ?Le nombre de pays ?Son système de coordonnées et de référence (SCR) ?E2. Exécutez le code qui “généré” la carte du monde dans la section 2.2.3 (Création de cartes de base).\nTrouvez deux similitudes et deux différences entre l’image sur votre ordinateur et celle du livre.Que fait l’argument cex (voir ?plot) ?Pourquoi le paramètre cex -t-il été fixé à sqrt(world$pop) / 10000 ?Bonus : expérimentez différentes façons de visualiser la population mondiale.E3. Utilisez plot() pour créer des cartes du Nigeria et les pays avoisinants (voir section 2.2.3).Ajustez les arguments lwd, col et expandBB de plot().Défi! : lisez la documentation de text() et annotez la carte.E4. Créez un objet SpatRaster vide appelé mon_raster avec 10 colonnes et 10 lignes.\nAttribuez des valeurs aléatoires entre 0 et 10 au nouveau raster et représentez-le.E5. Lisez le fichier raster/nlcd.tif du paquet spDataLarge.\nQuel type d’information pouvez-vous obtenir sur les propriétés de ce fichier ?E6. Regardez le SCR du fichier raster/nlcd.tif du paquet spDataLarge.\nQuel type d’information pouvez-vous en tirer ?","code":""},{"path":"attr.html","id":"attr","chapter":"3 Opérations sur les tables attributaires","heading":"3 Opérations sur les tables attributaires","text":"","code":""},{"path":"attr.html","id":"prérequis-1","chapter":"3 Opérations sur les tables attributaires","heading":"Prérequis","text":"Ce chapitre nécessite l’installation et le chargement des paquets suivant :Il s’appuie également sur spData, qui charge des jeux de données utilisés dans les exemples de ce chapitre :","code":"\nlibrary(sf)      # paquet pour les données vectorielles présenté dans le Chapitre 2\nlibrary(terra)   # paquet pour les données raster présenté dans le Chapitre 2\nlibrary(dplyr)   # paquet du tidyverse pour la manipulation de tableau de donnée\nlibrary(spData)  # paquet de données spatiales présenté dans le Chapitre 2"},{"path":"attr.html","id":"introduction","chapter":"3 Opérations sur les tables attributaires","heading":"3.1 Introduction","text":"Les données attributaires sont des informations non spatiales associées à des données géographiques (géométrie).\nUn arrêt de bus en est un exemple simple : sa position est généralement représentée par des coordonnées de latitude et de longitude (données géométriques), en plus de son nom.\nL’arrêt Elephant & Castle / New Kent Road à Londres, par exemple, pour coordonnées -0,098 degrés de longitude et 51,495 degrés de latitude, ce qui peut être représenté par POINT (-0,098 51,495) dans la représentation sfc décrite au chapitre 2.\nLes attributs tels que le nom attribut de élément POINT (pour utiliser la terminologie de Simple Features) sont le sujet de ce chapitre.Un autre exemple est la valeur d’élévation (attribut) pour un pixel spécifique dans les données raster.\nContrairement au modèle de données vectorielles, le modèle de données raster stocke indirectement les coordonnées de la cellule de grille, ce qui signifie que la distinction entre attribut et information spatiale est moins claire.\nPour illustrer ce point, pensez à un pixel dans la 3e ligne et la 4e colonne d’une matrice matricielle.\nSon emplacement spatial est défini par son indice dans la matrice : déplacez-vous depuis l’origine de quatre cellules dans la direction x (généralement vers l’est et la droite sur les cartes) et de trois cellules dans la direction y (généralement vers le sud et le bas).\nLa résolution de la trame définit la distance pour chaque étape x et y qui est spécifiée dans l’en-tête du fichier.\nL’en-tête est un composant essentiel des ensembles de données raster qui spécifie comment les pixels se rapportent aux coordonnées géographiques (voir également le chapitre ??).Vous apprendrez ainsi à manipuler des objets géographiques en fonction d’attributs, tels que le nom des arrêts de bus, dans un jeux de données vectorielles et l’altitude des pixels dans un jeux de données raster.\nPour les données vectorielles, cela implique des techniques telles que le sous-ensemble et l’agrégation (voir les sections ?? et ??).\nLes sections ?? et 3.2.5 montrent respectivement comment joindre des données à des objets simple features à l’aide d’un ID (identifiant) partagé et comment créer de nouvelles variables.\nChacune de ces opérations un équivalent spatial :\nL’opérateur [ de la version de base de R, par exemple, fonctionne pour faire des sous-ensembles d’objets basé sur leur attribut que ces objets soient spatiaux ou non ; vous pouvez également joindre les attributs de deux jeux de données géographiques à l’aide de jointures spatiales.\nC’est une bonne nouvelle : les compétences développées dans ce chapitre sont transférables.\nLe chapitre ?? étend les méthodes présentées ici au monde spatial.Après une exploration en profondeur dans les différents types d’opérations sur les attributs vectoriels, les opérations sur les données attributaires raster sont abordées dans la section ??. Elle montrera comment créer des couches raster contenant des attributs continus et catégoriels et comment extraire les valeurs des cellules d’une ou de plusieurs couches (sous-ensemble raster).\nLa section ?? fournit une vue d’ensemble des calculs matricielles “globaux” qui peuvent être utilisées pour résumer des jeux de données raster entiers.","code":""},{"path":"attr.html","id":"manipulations-des-attributs-de-données-vectorielles.","chapter":"3 Opérations sur les tables attributaires","heading":"3.2 Manipulations des attributs de données vectorielles.","text":"Les jeux de données géographiques vectorielles sont bien supportés dans R grâce à la classe sf, qui étend la classe data.frame de R.\nComme les tableaux de données, les objets sf ont une colonne par variable attributaire (comme le ‘nom’) et une ligne par observation ou élément (par exemple, par station de bus).\nLes objets sf diffèrent des cadres de données de base parce qu’ils ont une colonne geometry de la classe sfc qui peut contenir une gamme d’entités géographiques (points simples et ‘multi’, lignes et polygones) par ligne.\nCeci été décrit dans le chapitre 2, qui démontré comment les méthodes génériques telles que plot() et summary() fonctionnent avec les objets sf.\nsf fournit également des méthodes génériques permettant aux objets sf de se comporter comme des tableaux de données ordinaires, comme le montre l’impression des méthodes de la classe :Beaucoup d’entre elles (aggregate(), cbind(), merge(), rbind() et [) servent à manipuler des tableaux de données.\nrbind(), par exemple, lie deux tableaux de données, l’un “au-dessus” de l’autre.\n$<- crée de nouvelles colonnes.\nUne caractéristique essentielle des objets sf est qu’ils stockent des données spatiales et non spatiales de la même manière, comme des colonnes dans un data.frame.La colonne géométrique des objets sf est typiquement appelée geometry ou geom mais n´importe quel nom peut être utilisé.\nLa commande suivante, par exemple, crée une colonne géométrique nommée g :st_sf(data.frame(n = world$name_long), g = world$geom)Les objets sf peuvent également étendre les classes tidyverse pour les tableaux de données, tibble et tbl.\n.\nAinsi, sf permet d’utiliser toute la puissance des capacités d’analyse de données de R sur les données géographiques, que vous utilisiez les fonctions de base de R ou du tidyverse pour l’analyse des données.\n\n(Voir Rdatatable/data.table#2273 pour une discussion sur la compatibilité entre les objets sf et le paquet data.table très rapide).\nAvant d’utiliser ces capacités, il est utile de rappeler comment découvrir les propriétés de base des objets de données vectorielles.\nCommençons par utiliser les fonctions de base de R pour découvrir l’ensemble de données world du paquet spData.world contient dix colonnes non-géographiques (et une colonne de liste de géométrie) avec presque 200 lignes représentant les pays du monde.\nLa fonction st_drop_geometry() ne conserve que les données attributaires d’un objet sf, c’est-à-dire qu’elle supprime sa géométrie.Il peut être utile de supprimer la colonne de géométrie avant de travailler avec des données attributaires ; les processus de manipulation des données peuvent s’exécuter plus rapidement lorsqu’ils ne travaillent que sur les attributs et les colonnes de géométrie ne sont pas toujours nécessaires.\nDans la plupart des cas, cependant, il est judicieux de conserver la colonne géométrique, ce qui explique pourquoi cette colonne est “collante” (elle reste après la plupart des opérations sur les attributs, sauf si elle est spécifiquement abandonnée).\nLes opérations de données non spatiales sur les objets sf ne modifient la géométrie d’un objet que lorsque cela est approprié (par exemple, en supprimant les frontières entre les polygones adjacents après l’agrégation).\nDevenir compétent dans la manipulation des données d’attributs géographiques signifie devenir compétent dans la manipulation des tableaux de données.Pour de nombreuses applications, le paquet du tidyverse dplyr offre une approche efficace pour travailler avec des tableau de données.\nLa compatibilité avec le tidyverse est un avantage de sf par rapport à son prédécesseur sp, mais il y quelques pièges à éviter (voir la vignette supplémentaire tidyverse-pitfalls à geocompr.github.io pour plus de détails).","code":"\nmethods(class = \"sf\") # liste des 12 premières méthodes possibles avec la class sf \n#>  [1] aggregate             cbind                 coerce               \n#>  [4] initialize            merge                 plot                 \n#>  [7] print                 rbind                 [                    \n#> [10] [[<-                  $<-                   show                 \nclass(world) # c'est un objet sf et un (tidy) data.frame\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\ndim(world)   # c'est un objet de deux dimensions avec 177 lignes et 11 colonnes\n#> [1] 177  11\nworld_df = st_drop_geometry(world)\nclass(world_df)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\nncol(world_df)\n#> [1] 10"},{"path":"attr.html","id":"sélection-de-sous-ensemble-dans-des-attributs-de-données-vectorielles","chapter":"3 Opérations sur les tables attributaires","heading":"3.2.1 Sélection de sous ensemble dans des attributs de données vectorielles","text":"Les méthodes de sélection de sous-ensembles de base de R incluent l’opérateur [ et la fonction subset().\nLes principales fonctions de sélection de sous-ensembles dplyr sont filter() et slice() pour la sélection des lignes, et select() pour la sélection des colonnes.\nCes deux approches préservent les composantes spatiales des données attributaires dans les objets sf, tandis que l’utilisation de l’opérateur $ ou de la fonction dplyr pull() pour retourner une seule colonne d’attribut sous forme de vecteur perdra les données d’attribut, comme nous le verrons plus loin.\n\nCette section se concentre sur la sélection de sous-ensemble de tableaux de données sf ; pour plus de détails sur les cas de vecteur et de tableaux de données non géographiques, nous vous recommandons de lire respectivement la section 2.7 de Introduction R (R Core Team, Smith, Team 2021) et le chapitre 4 de Advanced R Programming (Wickham 2019).L’opérateur [ peut sélectionner à la fois les lignes et les colonnes.\nDes chiffres d’index placés entre crochets directement après le nom d’un objet de type tableau de données spécifient les éléments à conserver.\nLa commande object[, j] signifie ’retourner les lignes représentées par et les colonnes représentées par j, où et j contiennent typiquement des entiers ou des TRUEs et FALSEs (les index peuvent aussi être des chaînes de caractères, indiquant les noms de lignes ou de colonnes).\nPar exemple, objet[5, 1:3] signifie ’retourner des données contenant la cinquième ligne et les colonnes 1 à 3 : le résultat devrait être un tableau de données avec seulement une ligne et trois colonnes, et une quatrième colonne de géométrie si c’est un objet sf.\nLaisser ou j vide retourne toutes les lignes ou colonnes, donc world[1:5, ] retourne les cinq premières lignes et les 11 colonnes.\nLes exemples ci-dessous illustrent les sélections avec la base R.\nDevinez le nombre de lignes et de colonnes dans les tableaux de données sf retournés par chaque commande et vérifiez les résultats sur votre propre ordinateur (cf. la fin du chapitre pour d’autres exercices) :Une démonstration de l’utilité de l’utilisation de vecteurs logiques pour la sélection est démontrée dans le morceau de code ci-dessous.\nIl crée un nouvel objet, small_countries, contenant les nations dont la surface est inférieure à 10,000 km2 :L’objet intermédiaire i_small (abréviation de l’index représentant les petits pays) est un vecteur logique qui peut être utilisé pour sélectionner les sept plus petits pays du monde en fonction de leur superficie.\nUne commande plus concise, qui omet l’objet intermédiaire, génère le même résultat :La fonction de base de R subset() fournit un autre moyen d’obtenir le même résultat :Les fonctions de base de R sont matures, stables et largement utilisées, ce qui en fait un choix solide, en particulier dans les contextes où la reproductibilité et la fiabilité sont essentielles.\nLes fonctions dplyr permettent des flux de travail “ordonnés” que certaines personnes (dont les auteurs de ce livre) trouvent intuitifs et productifs pour l’analyse interactive des données, en particulier lorsqu’elles sont associées à des éditeurs de code tels que RStudio qui permettent l’auto-complétion des noms de colonnes.\nLes fonctions clés pour les sélection dans les tableaux de données (y compris les tableaux de données sf) avec les fonctions dplyr sont démontrées ci-dessous.\n\n\n\nselect() sélectionne les colonnes par nom ou par leur position.\nPar exemple, vous pouvez sélectionner seulement deux colonnes, name_long et pop, avec la commande suivante :Note : comme avec la commande équivalente de base de R (world[, c(\"name_long\", \"pop\")]), la colonne collante geom reste.\nselect() permet également de sélectionner une plage de colonnes à l’aide de l’opérateur : :Vous pouvez supprimer des colonnes spécifiques avec l’opérateur - :Sélectionner et renommer les colonnes en même temps avec la syntaxe nouveau_nom = ancien_nom :Il est intéressant de noter que la commande ci-dessus est plus concise que l’équivalent de base R, qui nécessite deux lignes de code :select() fonctionne également avec des “fonctions d’aide” pour des opérations de sélections plus avancées, notamment contains(), starts_with() et num_range() (voir la page d’aide de ?select pour plus de détails).La plupart des verbes de dplyr retournent un tableau de données, mais vous pouvez extraire une seule colonne comme un vecteur avec pull().\n\n\n\nVous pouvez obtenir le même résultat grâce seulement avec la base de R avec les opérateurs de sélection de listes $ et [[, les trois commandes suivantes retournent le même tableau numérique :slice() est l’équivalent pour les lignes de select().\nLe morceau de code suivant, par exemple, sélectionne les lignes 1 à 6 :filter() est l’équivalent pourdplyr de la fonction subset() de R de base.\nElle ne conserve que les lignes correspondant à des critères donnés, par exemple, uniquement les pays dont la superficie est inférieure à un certain seuil, ou dont l’espérance de vie moyenne est élevée, comme le montrent les exemples suivants :L’ensemble des opérateurs de comparaison peut être utilisé dans la fonction filter(), comme illustré dans le tableau 3.1 :TABLE 3.1: Opérateurs de comparaison renvoyant des booléens (TRUE/FALSE).","code":"\nworld[1:6, ]    # sélection de lignes par position\nworld[, 1:3]    # sélection de colonnes par position\nworld[1:6, 1:3] # sélection de lignes et  colonnes par position\nworld[, c(\"name_long\", \"pop\")] # sélection de colonnes par leurs noms\nworld[, c(T, T, F, F, F, F, F, T, T, F, F)] # sélection en utilisant un vecteur logique\nworld[, 888] # un index référencent une colonne non-existente\ni_small = world$area_km2 < 10000\nsummary(i_small) # on confirme le vecteur logique\n#>    Mode   FALSE    TRUE \n#> logical     170       7\nsmall_countries = world[i_small, ]\nsmall_countries = world[world$area_km2 < 10000, ]\nsmall_countries = subset(world, area_km2 < 10000)\nworld1 = dplyr::select(world, name_long, pop)\nnames(world1)\n#> [1] \"name_long\" \"pop\"       \"geom\"\n# toutes les colonnes entre name_long et pop incluses\nworld2 = dplyr::select(world, name_long:pop)\n# toutes les colonnes sauf subregion et area_km2 \nworld3 = dplyr::select(world, -subregion, -area_km2)\nworld4 = dplyr::select(world, name_long, population = pop)\nworld5 = world[, c(\"name_long\", \"pop\")] # sélectionne les colonnes par nom\nnames(world5)[names(world5) == \"pop\"] = \"population\" # renommer les colonnes\npull(world, pop)\nworld$pop\nworld[[\"pop\"]]\nslice(world, 1:6)\nworld7 = filter(world ,area_km2 < 10000) # les pays avec une petite surface\nworld7 = filter(world, lifeExp > 82)      # ceux avec une grande espérance de vie"},{"path":"attr.html","id":"enchainement-de-commandes-avec-des-pipes","chapter":"3 Opérations sur les tables attributaires","heading":"3.2.2 Enchainement de commandes avec des pipes","text":"La clé des flux de travail utilisant les fonctions dplyr est l’opérateur ‘pipe’ %>% (ou depuis R 4.1.0 le pipe natif |>), qui tire son nom du pipe Unix | (Grolemund Wickham 2016).\nLes pipes permettent un code expressif : la sortie d’une fonction précédente devient le premier argument de la fonction suivante, permettant l’enchaînement.\nCeci est illustré ci-dessous, dans lequel seuls les pays d’Asie sont filtrés de l’ensemble de données world, l’objet est ensuite sélectionné par les colonnes (name_long et continent) et les cinq premières lignes (résultat non montré).Les lignes de code ci-dessus montre comment l’opérateur pipe permet d’écrire des commandes dans un ordre précis :\nles commandes ci-dessus sont écrites de haut en bas (ligne par ligne) et de gauche à droite.\nL’alternative à %>% est un appel de fonction imbriqué, ce qui est plus difficile à lire :","code":"\nworld7 = world %>%\n  filter(continent == \"Asia\") %>%\n  dplyr::select(name_long, continent) %>%\n  slice(1:5)\nworld8 = slice(\n  dplyr::select(\n    filter(world, continent == \"Asia\"),\n    name_long, continent),\n  1:5)"},{"path":"attr.html","id":"agrégation-sur-la-base-des-attributs-de-données-vectorielles","chapter":"3 Opérations sur les tables attributaires","heading":"3.2.3 Agrégation sur la base des attributs de données vectorielles","text":"\n\nL’agrégation consiste à résumer les données à l’aide d’une ou plusieurs “variables de regroupement”, généralement issues des colonnes du tableau de données à agréger (l’agrégation géographique est traitée au chapitre suivant).\nUn exemple d’agrégation d’attributs est le calcul du nombre d’habitants par continent à partir des données par pays (une ligne par pays).\nLe jeu de données world contient les ingrédients nécessaires : les colonnes pop et continent, respectivement la population et la variable de regroupement.\nLe est de trouver la somme() des populations des pays pour chaque continent, ce qui permet d’obtenir un tableau de données plus petit (l’agrégation est une forme de réduction des données et peut être une première étape utile lorsqu’travaille avec de grands jeux de données).\nCeci peut être fait avec la fonction de base de R aggregate() comme suit :Le résultat est un tableau de données non spatialisées comportant six lignes, une par continent, et deux colonnes indiquant le nom et la population de chaque continent (voir le tableau 3.2 avec les résultats pour les 3 continents les plus peuplés).aggregate() est une fonction générique ce qui signifie qu’elle se comporte différemment en fonction de ses entrées.\nsf fournit la méthode aggregate.sf() qui est activée automatiquement lorsque x est un objet sf et qu’un argument est fourni :L’objet world_agg2 résultant est un objet spatial contenant 8 entités représentant les continents du monde (et les océans).\ngroup_by() %>% summarize() est l’équivalent dplyr de aggregate(), avec le nom de variable fourni dans la fonction group_by() spécifiant la variable de regroupement et les informations sur ce qui doit être résumé passées à la fonction summarize(), comme indiqué ci-dessous :Cette approche peut sembler plus complexe mais elle présente des avantages : flexibilité, lisibilité et contrôle sur les nouveaux noms de colonnes.\nCette flexibilité est illustrée dans la commande ci-dessous, qui calcule non seulement la population mais aussi la superficie et le nombre de pays de chaque continent :Dans le morceau de code précédent, pop, area (sqkm) et n sont des noms de colonnes dans le résultat, et sum() et n() sont les fonctions d’agrégation.\nCes fonctions d’agrégation renvoient des objets sf avec des lignes représentant les continents et des géométries contenant les multiples polygones représentant chaque masse terrestre et les îles associées (cela fonctionne grâce à l’opération géométrique ‘union’, comme expliqué dans la section ??).Combinons ce que nous avons appris jusqu’à présent sur les fonctions dplyr, en enchaînant plusieurs commandes pour résumer les données attributaires des pays du monde entier par continent.\nLa commande suivante calcule la densité de population (avec mutate()), classe les continents selon le nombre de pays qu’ils contiennent (avec dplyr::arrange()), et ne conserve que les 3 continents les plus peuplés (avec top_n()), dont le résultat est présenté dans le Tableau 3.2) :TABLE 3.2: Les 3 continents les plus peuplés classés par densité de population (personnes par km carré).","code":"\nworld_agg1 = aggregate(pop ~ continent, FUN = sum, data = world,\n                       na.rm = TRUE)\nclass(world_agg1)\n#> [1] \"data.frame\"\nworld_agg2 = aggregate(world[\"pop\"], list(world$continent), FUN = sum, \n                       na.rm = TRUE)\nclass(world_agg2)\n#> [1] \"sf\"         \"data.frame\"\nnrow(world_agg2)\n#> [1] 8\nworld_agg3 = world %>%\n  group_by(continent) %>%\n  summarize(pop = sum(pop, na.rm = TRUE))\nworld_agg4  = world %>% \n  group_by(continent) %>%\n  summarize(pop = sum(pop, na.rm = TRUE), `area (sqkm)` = sum(area_km2), n = n())\nworld_agg5 = world %>% \n  st_drop_geometry() %>%                      # enlève la colonne géométrie pour un gain de temps\n  dplyr::select(pop, continent, area_km2) %>% # sélectionne les colonnes d’intérêt  \n  group_by(continent) %>%                     # regroupe par continents et synthétise:\n  summarize(Pop = sum(pop, na.rm = TRUE), Superficie = sum(area_km2), N = n()) %>%\n  mutate(Densité = round(Pop / Superficie)) %>%     # calcule la densité de population\n  top_n(n = 3, wt = Pop) %>%                  # ne garde que les 3 plus importants\n  arrange(desc(N))                            # trie par ordre du nombre de pays"},{"path":"attr.html","id":"jointures-attributaires-de-données-vectorielles","chapter":"3 Opérations sur les tables attributaires","heading":"3.2.4 Jointures attributaires de données vectorielles","text":"La combinaison de données provenant de différentes sources est une tâche courante dans la préparation des données.\nLes jointures le font en combinant des tables basées sur une variable “clé” partagée.\ndplyr possède plusieurs fonctions de jointure, dont left_join() et inner_join() — voir vignette(\"two-table\") pour une liste complète.\nCes noms de fonctions suivent les conventions utilisées dans le langage des base de données SQL (Grolemund Wickham 2016, Chapitre 13) ; leur utilisation pour joindre des ensembles de données non spatiales à des objets sf est l’objet de cette section.\nLes fonctions de jointure dplyr fonctionnent de la même manière sur les tableau de données et les objets sf, la seule différence importante étant la colonne de liste geometry.\nLe résultat des jointures de données peut être un objet sf ou data.frame.\nLe type le plus courant de jointure attributaures sur des données spatiales prend un objet sf comme premier argument et lui ajoute des colonnes à partir d’un data.frame spécifié comme second argument.\n\nPour démontrer les jointures, nous allons combiner les données sur la production de café avec l’ensemble de données world.\nLes données sur le café sont dans un tableau de données appelé coffee_data du paquet spData (voir ?coffee_data pour plus de détails).\nIl comporte 3 colonnes :\nname_long nomme les principales nations productrices de café et coffee_production_2016 et coffee_production_2017 contiennent les valeurs estimées de la production de café en unités de sacs de 60 kg pour chaque année.\nUne “jointure gauche” (left join), qui préserve le premier ensemble de données, fusionne world avec coffee_data :Comme les données d’entrée partagent une “variable clé” (name_long), la jointure fonctionne sans utiliser l’argument (voir ?left_join pour plus de détails).\nLe résultat est un objet sf identique à l’objet original world mais avec deux nouvelles variables (indexées comme les colonne 11 et 12) sur la production de café.\nCet objet peut être représenté sous forme de carte, comme l’illustre la figure 3.1, générée avec la fonction plot() ci-dessous :\nFIGURE 3.1: Production mondiale de café (milliers de sacs de 60 kg) par pays, 2017. Source : Organisation internationale du café.\nPour que la jointure fonctionne, une “variable clé” doit être fournie dans les deux ensembles de données.\nPar défaut, dplyr utilise toutes les variables dont le nom correspond.\nDans ce cas, les deux objets world_coffee et world contenaient une variable appelée name_long, expliquant le message Joining, = \"name_long\".\nDans la majorité des cas où les noms des variables ne sont pas les mêmes, vous avez deux options :Renommez la variable clé dans l’un des objets pour qu’ils correspondent.Utiliser l’argument pour spécifier les variables de jonction.Cette dernière approche est démontrée ci-dessous sur une version renommée de coffee_data :Note name original object kept, meaning world_coffee new object world_coffee2 identical.\nAnother feature result number rows original dataset.\nAlthough 47 rows data coffee_data, 177 country records kept intact world_coffee world_coffee2:\nrows original dataset match assigned NA values new coffee production variables.\nwant keep countries match key variable?\ncase inner join can used:Notez que le résultat de inner_join() ne comporte que 45 lignes contre 47 dans coffee_data.\nQu’est-il arrivé aux lignes restantes ?\nNous pouvons identifier les lignes qui ne correspondent pas en utilisant la fonction setdiff() comme suit :Le résultat montre que “Others” représente une ligne non présente dans la base de données “monde” et que le nom de la “Democratic Republic Congo” représente l’autre ligne :\nil été abrégé, ce qui fait que la jointure l’manqué.\nLa commande suivante utilise une fonction de correspondance de chaîne (regex) du paquet stringr pour confirmer ce que devrait être Congo, Dem. Rep. :Pour résoudre ce problème, nous allons créer une nouvelle version de coffee_data et mettre à jour le nom.\nEn utilisant le tableau de données mis à jour, inner_join() renvoie un résultat avec les 46 pays producteurs de café :Il est également possible d’effectuer une jointure dans l’autre sens : en partant d’un ensemble de données non spatiales et en ajoutant des variables provenant d’un objet simple features.\nCi-dessous, commence avec l’objet coffee_data et ajoute les variables du jeux de données world.\nContrairement aux jointures précédentes, le résultat n’est pas un autre objet simple features , mais un tableau de données sous la forme d’un tibble tidyverse :\nLe résultat d’une jointure tend à correspondre à son premier argument :Cette section couvre la majorité des cas d’utilisation de la jointure.\nPour plus d’informations, nous recommandons Grolemund Wickham (2016), la vignette join dans le paquet geocompkg qui accompagne ce livre, et la documentation du paquet data.table .18\nUn autre type de jointure est la jointure spatiale, traitée dans le chapitre suivant (section ??).","code":"\nworld_coffee = left_join(world, coffee_data)\n#> Joining, by = \"name_long\"\nclass(world_coffee)\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\nnames(world_coffee)\n#>  [1] \"iso_a2\"                 \"name_long\"              \"continent\"             \n#>  [4] \"region_un\"              \"subregion\"              \"type\"                  \n#>  [7] \"area_km2\"               \"pop\"                    \"lifeExp\"               \n#> [10] \"gdpPercap\"              \"geom\"                   \"coffee_production_2016\"\n#> [13] \"coffee_production_2017\"\nplot(world_coffee[\"coffee_production_2017\"])\ncoffee_renamed = rename(coffee_data, nm = name_long)\nworld_coffee2 = left_join(world, coffee_renamed, by = c(name_long = \"nm\"))\nworld_coffee_inner = inner_join(world, coffee_data)\n#> Joining, by = \"name_long\"\nnrow(world_coffee_inner)\n#> [1] 45\nsetdiff(coffee_data$name_long, world$name_long)\n#> [1] \"Congo, Dem. Rep. of\" \"Others\"\n(drc = stringr::str_subset(world$name_long, \"Dem*.+Congo\"))\n#> [1] \"Democratic Republic of the Congo\"\ncoffee_data$name_long[grepl(\"Congo,\", coffee_data$name_long)] = drc\nworld_coffee_match = inner_join(world, coffee_data)\n#> Joining, by = \"name_long\"\nnrow(world_coffee_match)\n#> [1] 46\ncoffee_world = left_join(coffee_data, world)\n#> Joining, by = \"name_long\"\nclass(coffee_world)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\""},{"path":"attr.html","id":"vec-attr-creation","chapter":"3 Opérations sur les tables attributaires","heading":"3.2.5 Création d’attributs et suppression d’informations spatiales","text":"Souvent, nous souhaitons créer une nouvelle colonne à partir de colonnes déjà existantes.\nPar exemple, nous voulons calculer la densité de population pour chaque pays.\nPour cela, nous devons diviser une colonne de population, ici pop, par une colonne de surface, ici area_km2 avec une unité de surface en kilomètres carrés.\nEn utilisant les fonctions de base de R, nous pouvons taper :Alternativement, nous pouvons utiliser l’une des fonctions dplyr - mutate() ou transmute().\nmutate() ajoute de nouvelles colonnes à l’avant-dernière position dans l’objet sf (la dernière est réservée à la géométrie) :La différence entre mutate() et transmute() est que ce dernier supprime toutes les autres colonnes existantes (à l’exception de la colonne de géométrie collante) :unite() du paquet tidyr (qui fournit de nombreuses fonctions utiles pour remodeler les ensembles de données, notamment pivot_longer()) colle ensemble des colonnes existantes.\nPar exemple, ici nous voulons combiner les colonnes continent et region_un dans une nouvelle colonne nommée con_reg.\nDe plus, nous pouvons définir un séparateur (ici : deux points :) qui définit comment les valeurs des colonnes d’entrée doivent être jointes, et si les colonnes originales doivent être supprimées (ici : TRUE) :La fonction separate() fait l’inverse de unite() : elle divise une colonne en plusieurs colonnes en utilisant soit une expression régulière, soit les positions des caractères.\nCette fonction provient également du paquetage tidyr.La fonction dplyr rename() et la fonction de base de R setNames() sont utiles pour renommer des colonnes.\nLa première remplace un ancien nom par un nouveau.\nIci, par exemple, elle renomme la longue colonne name_long en un simple name :setNames() change tous les noms de colonnes en une fois, et nécessite un vecteur de caractères avec un nom correspondant pour chaque colonne.\nCeci est illustré ci-dessous, qui produit le même objet world, mais avec des noms très courts :Il est important de noter que les opérations sur les données attributaires préservent la géométrie des simple features.\nComme mentionné au début du chapitre, il peut être utile de supprimer la géométrie.\nPour ce faire, vous devez la supprimer explicitement.\nPar conséquent, une approche telle que select(world, -geom) sera infructueuse et vous devriez plutôt utiliser st_drop_geometry().19","code":"\nworld_new = world # afin de ne pas écraser nos données\nworld_new$pop_dens = world_new$pop / world_new$area_km2\nworld %>% \n  mutate(pop_dens = pop / area_km2)\nworld %>% \n  transmute(pop_dens = pop / area_km2)\nworld_unite = world %>%\n  unite(\"con_reg\", continent:region_un, sep = \":\", remove = TRUE)\nworld_separate = world_unite %>% \n  separate(con_reg, c(\"continent\", \"region_un\"), sep = \":\")\nworld %>% \n  rename(name = name_long)\nnew_names = c(\"i\", \"n\", \"c\", \"r\", \"s\", \"t\", \"a\", \"p\", \"l\", \"gP\", \"geom\")\nworld %>% \n  setNames(new_names)\nworld_data = world %>% st_drop_geometry()\nclass(world_data)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\""},{"path":"attr.html","id":"manipuler-des-objets-raster","chapter":"3 Opérations sur les tables attributaires","heading":"3.3 Manipuler des objets raster","text":"Contrairement au modèle de données vectorielles qui sous-tend les simple features (qui représente les points, les lignes et les polygones comme des entités discrètes dans l’espace), les données matricielles représentent des surfaces continues.\nCette section présente le fonctionnement des objets raster en les créant de bout en bout, en s’appuyant sur la section ??.\nEn raison de leur structure unique, les sélections et les autres opérations sur les jeux de données raster fonctionnent d’une manière différente, comme le montre la section ??.\nLe code suivant recrée le jeu de données matricielles utilisé dans la section 2.3.4, dont le résultat est illustré dans la figure 3.2.\nCela montre comment la fonction rast() fonctionne pour créer un exemple de données matricielles nommé elev (représentant les élévations).Le résultat est un objet raster avec 6 lignes et 6 colonnes (spécifiées par les arguments nrow et ncol), et une étendue spatiale comprise dans les directions x et y (xmin, xmax, ymin, ymax).\nL’argument vals définit les valeurs que chaque cellule contient : des données numériques allant de 1 à 36 dans ce cas.\nLes objets raster peuvent également contenir des valeurs catégorielles de la classe des variables logiques ou factor de R.\nLe code suivant crée les ensembles de données matricielles illustrés dans la figure 3.2 :L’objet raster stocke la table de correspondance ou “Raster Attribute Table” (RAT) correspondante sous la forme d’une liste de tableau de données, qui peuvent être visualisés avec cats(grain) (cf. ?cats() pour plus d’informations).\nChaque élément de cette liste est une couche du raster.\nIl est également possible d’utiliser la fonction levels() pour récupérer et ajouter de nouveaux niveaux de facteurs ou remplacer des niveaux existants\nFIGURE 3.2: Jeux de données raster avec des valeurs numériques (à gauche) et catégorielles (à droite).\n","code":"\nelev = rast(nrows = 6, ncols = 6, resolution = 0.5, \n            xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n            vals = 1:36)\ngrain_order = c(\"clay\", \"silt\", \"sand\")\ngrain_char = sample(grain_order, 36, replace = TRUE)\ngrain_fact = factor(grain_char, levels = grain_order)\ngrain = rast(nrows = 6, ncols = 6, resolution = 0.5, \n             xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n             vals = grain_fact)\nlevels(grain)[[1]] = c(levels(grain)[[1]], wetness = c(\"wet\", \"moist\", \"dry\"))\nlevels(grain)\n#> [[1]]\n#> [1] \"clay\"  \"silt\"  \"sand\"  \"wet\"   \"moist\" \"dry\""},{"path":"attr.html","id":"sélection-sur-des-raster","chapter":"3 Opérations sur les tables attributaires","heading":"3.3.1 Sélection sur des raster","text":"La sélection de données raster est réalisé à l’aide de l’opérateur de base de R [, qui accepte une large gamme d’entrées :\nIndexation ligne-colonneID des cellulesCoordonnées (voir la section ??)Autre objet spatial (voir la section ??)Nous ne présentons ici que les deux premières options, car elles peuvent être considérées comme des opérations non spatiales.\nSi nous avons besoin d’un objet spatial pour en sélectionner un autre ou si le résultat est un objet spatial, nous en parlerons comme une sélection spatiale.\nPar conséquent, les deux dernières options seront présentées dans le chapitre suivant (voir la section ??).Les deux premières options de sous-ensembles sont présentées dans les commandes ci-dessous —\ntoutes deux renvoient la valeur du pixel supérieur gauche dans l’objet raster elev (résultats non montrés) :Les sélections d’objets raster à couches multiples renverront la ou les valeurs des cellules pour chaque couche.\nPar exemple, c(elev, grain)[1] renvoie un cadre de données avec une ligne et deux colonnes — une pour chaque couche.\nPour extraire toutes les valeurs ou des lignes complètes, vous pouvez également utiliser values().Les valeurs des cellules peuvent être modifiées en écrasant les valeurs existantes en conjonction avec une opération de sélection.\nL’exemple de code suivant, par exemple, définit la cellule supérieure gauche de elev à 0 (résultats non montrés) :Laisser les crochets vides est une version raccourcie de values() pour récupérer toutes les valeurs d’un raster.\nPlusieurs cellules peuvent également être modifiées de cette manière :Le remplacement des valeurs des rasters multicouches peut se faire avec une matrice comportant autant de colonnes que de couches et de lignes que de cellules remplaçables (résultats non montrés) :","code":"\n# ligne 1, colonne 1\nelev[1, 1]\n# pixel ID 1\nelev[1]\nelev[1, 1] = 0\nelev[]\nelev[1, c(1, 2)] = 0\ntwo_layers = c(grain, elev) \ntwo_layers[1] = cbind(c(0), c(4))\ntwo_layers[]"},{"path":"attr.html","id":"résumer-les-objets-raster","chapter":"3 Opérations sur les tables attributaires","heading":"3.3.2 Résumer les objets raster","text":"terra contient des fonctions permettant d’extraire des statistiques descriptives pour des rasters entiers.\nL’impression d’un objet raster sur la console en tapant son nom renvoie les valeurs minimales et maximales d’un objet raster.\nsummary() fournit des statistiques descriptives courantes – minimum, maximum, quartiles et nombre de NAs pour les matrices continues et un nombre de cellules de chaque classe pour les matrices catégorielles.\nD’autres opérations de synthèse telles que l’écart-type (voir ci-dessous) ou des statistiques de synthèse personnalisées peuvent être calculées avec global().\nDe plus, la fonction freq() permet d’obtenir le tableau de fréquence des valeurs catégorielles.Les statistiques des données raster peuvent être visualisées de différentes manières.\nDes fonctions spécifiques telles que boxplot(), density(), hist() et pairs() fonctionnent également avec les objets raster, comme le montre l’histogramme créé avec la commande ci-dessous (non montré) :Si la fonction de visualisation souhaitée ne fonctionne pas avec les objets raster, peut extraire les données à représenter à l’aide de values() (section ??).\nLes statistiques descriptives sur des raster font partie des opérations raster dites globales.\nCes opérations, ainsi que d’autres opérations de traitement raster typiques, font partie du traitement algébrique sur raster, qui est abordé dans le chapitre suivant (section ??).\nCertains noms de fonctions sont réutilisés entre les paquets et\nrentrent en conflit(par exemple, une fonction avec le nom\nextract() existe à la fois dans les paquets\nterra et tidyr). En plus de ne pas\ncharger les paquets en se référant verbalement aux fonctions (par\nexemple, tidyr::extract()), une autre façon d’éviter les\nconflits de noms de fonctions est de décharger le paquet en question\navec detach(). La commande suivante, par exemple, décharge\nle paquet terra (ceci peut également être fait dans\nl’onglet package qui se trouve par défaut dans le panneau\ninférieur droit de RStudio) :\ndetach(“package:terra”, unload = TRUE, force = TRUE).\nL’argument force permet de s’assurer que le paquet sera\ndétaché même si d’autres paquets en dépendent. Cependant, cela peut\nconduire à une utilisation restreinte des paquets dépendant du paquet\ndétaché, et n’est donc pas recommandé.\n","code":"\nglobal(elev, sd)\nhist(elev)"},{"path":"attr.html","id":"exercises-1","chapter":"3 Opérations sur les tables attributaires","heading":"3.4 Exercises","text":"exercises use us_states us_states_df datasets spData package.\nmust attached package, packages used attribute operations chapter (sf, dplyr, terra) commands library(spData) attempting exercises:us_states spatial object (class sf), containing geometry attributes (including name, region, area, population) states within contiguous United States.\nus_states_df data frame (class data.frame) containing name additional variables (including median income poverty level, years 2010 2015) US states, including Alaska, Hawaii Puerto Rico.\ndata comes United States Census Bureau, documented ?us_states ?us_states_df.E1. Create new object called us_states_name contains NAME column us_states object using either base R ([) tidyverse (select()) syntax.\nclass new object makes geographic?E2. Select columns us_states object contain population data.\nObtain result using different command (bonus: try find three ways obtaining result).\nHint: try use helper functions, contains matches dplyr (see ?contains).E3. Find states following characteristics (bonus find plot ):Belong Midwest region.Belong West region, area 250,000 km2and 2015 population greater 5,000,000 residents (hint: may need use function units::set_units() .numeric()).Belong South region, area larger 150,000 km2 total population 2015 larger 7,000,000 residents.E4. total population 2015 us_states dataset?\nminimum maximum total population 2015?E5. many states region?E6. minimum maximum total population 2015 region?\ntotal population 2015 region?E7. Add variables us_states_df us_states, create new object called us_states_stats.\nfunction use ?\nvariable key datasets?\nclass new object?E8. us_states_df two rows us_states.\ncan find ? (hint: try use dplyr::anti_join() function)E9. population density 2015 state?\npopulation density 2010 state?E10. much population density changed 2010 2015 state?\nCalculate change percentages map .E11. Change columns’ names us_states lowercase. (Hint: helper functions - tolower() colnames() may help.)E12. Using us_states us_states_df create new object called us_states_sel.\nnew object two variables - median_income_15 geometry.\nChange name median_income_15 column Income.E13. Calculate change number residents living poverty level 2010 2015 state. (Hint: See ?us_states_df documentation poverty level columns.)\nBonus: Calculate change percentage residents living poverty level state.E14. minimum, average maximum state’s number people living poverty line 2015 region?\nBonus: region largest increase people living poverty line?E15. Create raster scratch nine rows columns resolution 0.5 decimal degrees (WGS84).\nFill random numbers.\nExtract values four corner cells.E16. common class example raster grain (hint: modal)?E17. Plot histogram boxplot dem.tif file spDataLarge package (system.file(\"raster/dem.tif\", package = \"spDataLarge\")).","code":"\nlibrary(sf)\nlibrary(dplyr)\nlibrary(terra)\nlibrary(spData)\ndata(us_states)\ndata(us_states_df)"}]
